!function(){this.global=this,this.window=this}(),function(n){function t(a){if(e[a])return e[a].exports;var s=e[a]={i:a,l:!1,exports:{}};return n[a].call(s.exports,s,s.exports,t),s.l=!0,s.exports}var e={};t.m=n,t.c=e,t.i=function(n){return n},t.d=function(n,e,a){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:a})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},t.p="",t(t.s=356)}({112:/*!************************************!*\
  !*** ./engine/statistics/index.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("\nconst Statistic = __webpack_require__(/*! ./Statistic */ 127);\nconst topsort = __webpack_require__(/*! ./topsort */ 179);\nconst definitions = __webpack_require__(/*! ./definitions */ 178);\nconst metadata = __webpack_require__(/*! ./metadata.json */ 145);\n\n// used for t-stat calculations\n//let VdivwSq = V.dotDivide(w).dotPow(2);\n\nconst sorted = topsort(definitions);\n\nconst noShow = metadata.filter(({ show }) => !show);\n\nmodule.exports = predefinedStats => {\n  let stats = sorted.reduce((calculatedStats, stat) => stat.calc(calculatedStats), predefinedStats);\n\n  /*\n  for (let key of noShow) {\n    delete stats[key];\n  }\n   */\n\n  return stats;\n};\n\nmodule.exports.compute = (stat, args) => {\n  stat_def = definitions.find(s => s.name === stat);\n\n  if (stat_def == null) {\n    throw new ReferenceError('Cannot find statistic \\'' + stat + '\\'');\n  }\n  return stat_def.calc(args)[stat];\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/index.js\n// module id = 112\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/index.js?")},113:/*!***************************************************!*\
  !*** ./interface/components/transform/label.json ***!
  \***************************************************/
function(module,exports){eval('module.exports = {\n\t"LOG": "log",\n\t"K_ORDER_DIFFERENCE": "K-Order_difference",\n\t"STANDARDIZE": "Standardize",\n\t"RESCALE": "Scale_by_RMS",\n\t"Transform": {\n\t\t"delete": 0,\n\t\t"log": 1,\n\t\t"k_order_diff": 2,\n\t\t"standardize": 3,\n\t\t"rescale": 4\n\t}\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./interface/components/transform/label.json\n// module id = 113\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./interface/components/transform/label.json?')},126:/*!************************************************!*\
  !*** ./engine/regression/svd-golub-reinsch.js ***!
  \************************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Matrix = __webpack_require__(/*! ../matrix */ 65);\n\nfunction pythag(a, b) {\n  var absa = Math.abs(a),\n      absb = Math.abs(b);\n\n  return absa > absb ? absa * Math.sqrt(1 + Math.pow(absb / absa, 2)) : absb === 0 ? 0 : absb * Math.sqrt(1 + Math.pow(absa / absb, 2));\n}\n\n/**\n * Translation of the SVD algorithm published in Numer. Math. 14, 403-420 (1970)\n * by G. H. Golub and C. Reinsch.\n *\n * Source: http://cs.brown.edu/courses/csci0530/current/homeworks/svd.py\n *\n * @param {Matrix<m,n>} A Matrix to decompose (m >= n)\n * @return {[Matrix<m,m>, Matrix<m,n>, Matrix<n,n>]} [U, E, V] s.t. A = U*E*V\n */\nfunction svd(A) {\n  var eps = Number.EPSILON,\n      tol = Number.MIN_VALUE / eps;\n\n  if (1.0 + eps <= 1.0) {\n    throw new Error('Make eps bigger');\n  }\n  if (tol <= 0.0) {\n    throw new Error('Make tol bigger');\n  }\n\n  var itmax = 50,\n      u = A.clone(),\n      m = u.shape[0],\n      n = u.shape[1],\n      e = [],\n      q = [],\n      v = new Matrix(n, n),\n      g = 0.0,\n      x = 0.0,\n      i,\n      j,\n      k,\n      l,\n      s,\n      f,\n      h,\n      y,\n      iteration,\n      gotoTestFConvergence,\n      z,\n      c,\n      l1;\n\n  if (m < n) {\n    throw new Error('m is less than n');\n  }\n\n  for (i = 0; i < n; i++) {\n    e[i] = g;\n    s = 0.0;\n    l = i + 1;\n    for (j = i; j < m; j++) s += u.data[j * n + i] * u.data[j * n + i];\n    if (s < tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i * n + i];\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n      h = f * g - s;\n      u.data[i * n + i] = f - g;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = i; k < m; k++) s += u.data[k * n + i] * u.data[k * n + j];\n        f = s / h;\n        for (k = i; k < m; k++) u.data[k * n + j] = u.data[k * n + j] + f * u.data[k * n + i];\n      }\n    }\n    q[i] = g;\n    s = 0.0;\n    for (j = l; j < n; j++) s = s + u.data[i * n + j] * u.data[i * n + j];\n    if (s <= tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i * n + i + 1];\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n      h = f * g - s;\n      u.data[i * n + i + 1] = f - g;\n      for (j = l; j < n; j++) e[j] = u.data[i * n + j] / h;\n      for (j = l; j < m; j++) {\n        s = 0.0;\n        for (k = l; k < n; k++) s = s + u.data[j * n + k] * u.data[i * n + k];\n        for (k = l; k < n; k++) u.data[j * n + k] = u.data[j * n + k] + s * e[k];\n      }\n    }\n    y = Math.abs(q[i]) + Math.abs(e[i]);\n    if (y > x) {\n      x = y;\n    }\n  }\n  // accumulation of right hand transformations\n  for (i = n - 1; i > -1; i--) {\n    if (g !== 0) {\n      h = g * u.data[i * n + i + 1];\n      for (j = l; j < n; j++) v.data[j * n + i] = u.data[i * n + j] / h;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = l; k < n; k++) s += u.data[i * n + k] * v.data[k * n + j];\n        for (k = l; k < n; k++) v.data[k * n + j] += s * v.data[k * n + i];\n      }\n    }\n    for (j = l; j < n; j++) {\n      v.data[i * n + j] = 0.0;\n      v.data[j * n + i] = 0.0;\n    }\n    v.data[i * n + i] = 1.0;\n    g = e[i];\n    l = i;\n  }\n  // accumulation of left hand transformations\n  for (i = n - 1; i > -1; i--) {\n    l = i + 1;\n    g = q[i];\n    for (j = l; j < n; j++) u.data[i * n + j] = 0.0;\n    if (g !== 0.0) {\n      h = u.data[i * n + i] * g;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = l; k < m; k++) s += u.data[k * n + i] * u.data[k * n + j];\n        f = s / h;\n        for (k = i; k < m; k++) u.data[k * n + j] += f * u.data[k * n + i];\n      }\n      for (j = i; j < m; j++) u.data[j * n + i] = u.data[j * n + i] / g;\n    } else {\n      for (j = i; j < m; j++) u.data[j * n + i] = 0.0;\n    }\n    u.data[i * n + i] += 1.0;\n  }\n  // diagonalization of the bidiagonal form\n  eps = eps * x;\n  for (k = n - 1; k > -1; k--) {\n    for (iteration = 0; iteration < itmax; iteration++) {\n      // test f splitting\n      for (l = k; l > -1; l--) {\n        gotoTestFConvergence = false;\n        if (Math.abs(e[l]) <= eps) {\n          // goto test f convergence\n          gotoTestFConvergence = true;\n          break;\n        }\n        if (Math.abs(q[l - 1]) <= eps) {\n          // goto cancellation\n          break;\n        }\n      }\n      if (!gotoTestFConvergence) {\n        // cancellation of e[l] if l>0\n        c = 0.0;\n        s = 1.0;\n        l1 = l - 1;\n        for (i = l; i < k + 1; i++) {\n          f = s * e[i];\n          e[i] = c * e[i];\n          if (Math.abs(f) <= eps) {\n            // goto test f convergence\n            break;\n          }\n          g = q[i];\n          h = pythag(f, g);\n          q[i] = h;\n          c = g / h;\n          s = -f / h;\n          for (j = 0; j < m; j++) {\n            y = u.data[j * n + l1];\n            z = u.data[j * n + i];\n            u.data[j * n + l1] = y * c + z * s;\n            u.data[j * n + i] = -y * s + z * c;\n          }\n        }\n      }\n      // test f convergence\n      z = q[k];\n      if (l === k) {\n        // convergence\n        if (z < 0.0) {\n          // q[k] is made non-negative\n          q[k] = -z;\n          for (j = 0; j < n; j++) {\n            v.data[j * n + k] = -v.data[j * n + k];\n          }\n        }\n        break; // break out of iteration loop and move on to next k value\n      }\n      if (iteration >= itmax - 1) {\n        throw new Error('SVD: No convergence');\n      }\n      // shift from bottom 2x2 minor\n      x = q[l];\n      y = q[k - 1];\n      g = e[k - 1];\n      h = e[k];\n      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\n      g = pythag(f, 1.0);\n      if (f < 0) {\n        f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x;\n      } else {\n        f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x;\n      }\n      // next QR transformation\n      c = 1.0;\n      s = 1.0;\n      for (i = l + 1; i < k + 1; i++) {\n        g = e[i];\n        y = q[i];\n        h = s * g;\n        g = c * g;\n        z = pythag(f, h);\n        e[i - 1] = z;\n        c = f / z;\n        s = h / z;\n        f = x * c + g * s;\n        g = -x * s + g * c;\n        h = y * s;\n        y = y * c;\n        for (j = 0; j < n; j++) {\n          x = v.data[j * n + i - 1];\n          z = v.data[j * n + i];\n          v.data[j * n + i - 1] = x * c + z * s;\n          v.data[j * n + i] = -x * s + z * c;\n        }\n        z = pythag(f, h);\n        q[i - 1] = z;\n        c = f / z;\n        s = h / z;\n        f = c * g + s * y;\n        x = -s * g + c * y;\n        for (j = 0; j < m; j++) {\n          y = u.data[j * n + i - 1];\n          z = u.data[j * n + i];\n          u.data[j * n + i - 1] = y * c + z * s;\n          u.data[j * n + i] = -y * s + z * c;\n        }\n      }\n      e[l] = 0.0;\n      e[k] = f;\n      q[k] = x;\n      // goto test f splitting\n    }\n  }\n\n  return [u, q, v];\n}\n\nmodule.exports = svd;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/svd-golub-reinsch.js\n// module id = 126\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/svd-golub-reinsch.js?")},127:/*!****************************************!*\
  !*** ./engine/statistics/Statistic.js ***!
  \****************************************/
function(module,exports){eval("\nconst defaults = ['X', 'y', 'BHat'];\n\nclass Statistic {\n\n  constructor(name, args, fn, description) {\n    this.name = name;\n    this.args = args;\n    this.fn = fn;\n  }\n\n  calc(statistics) {\n    statistics[this.name] = this.fn(statistics);\n    return statistics;\n  }\n\n  inspect(depth, options = { stylize: x => '' + x }) {\n    return `${this.name}(${this.args})`;\n  }\n\n}\n\nmodule.exports = (...args) => new Statistic(...args);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/Statistic.js\n// module id = 127\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/Statistic.js?")},128:/*!*************************************************!*\
  !*** ./engine/statistics/distributions-socr.js ***!
  \*************************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction statcom(q, i, j, b) {\n  var zz = 1,\n      z = zz,\n      k = i;\n\n  while (k <= j) {\n    zz *= q * k / (k - b);\n    z += zz;\n    k += 2;\n  }\n  return z;\n}\n\n/**\n * Two sided T-distribution estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} t T-statistic for some independent variable\n * @param {Number} n Degrees of freedom\n * @return {Number} 2-tailed p-value for the t statistic ( Pr(t) )\n */\nfunction pt(t, n) {\n  t = Math.abs(t);\n\n  var w = t / Math.sqrt(n),\n      th = Math.atan(w);\n\n  if (n === 1) {\n    return 1 - th / (Math.PI / 2);\n  }\n\n  var sth = Math.sin(th),\n      cth = Math.cos(th);\n\n  if (n % 2 === 1) {\n    return 1 - (th + sth * cth * statcom(cth * cth, 2, n - 3, -1)) / (Math.PI / 2);\n  }\n  return 1 - sth * statcom(cth * cth, 1, n - 3, -1);\n}\n\n/**\n * Fisher's F-density estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} f  F value for the model\n * @param {Number} n1 # of terms in the model\n * @param {Number} n2 Degrees of freedom\n * @return {Number} Probability of (F < f)\n */\nfunction pf(f, n1, n2) {\n  var x = n2 / (n1 * f + n2);\n\n  if (n1 % 2 === 0) {\n    return statcom(1 - x, n2, n1 + n2 - 4, n2 - 2) * Math.pow(x, n2 / 2);\n  }\n  if (n2 % 2 === 0) {\n    return 1 - statcom(x, n1, n1 + n2 - 4, n1 - 2) * Math.pow(1 - x, n1 / 2);\n  }\n\n  var th = Math.atan(Math.sqrt(n1 * f / n2)),\n      a = th / (Math.PI / 2),\n      sth = Math.sin(th),\n      cth = Math.cos(th);\n\n  if (n2 > 1) {\n    a += sth * cth * statcom(cth * cth, 2, n2 - 3, -1) / (Math.PI / 2);\n  }\n  if (n1 === 1) {\n    return 1 - a;\n  }\n\n  var c = 4 * statcom(sth * sth, n2 + 1, n1 + n2 - 4, n2 - 2) * sth * Math.pow(cth, n2) / Math.PI;\n\n  if (n2 === 1) {\n    return 1 - a + c / 2;\n  }\n\n  var k = 2;\n\n  while (k <= (n2 - 1) / 2) {\n    c *= k / (k - 0.5);\n    k += 1;\n  }\n  return 1 - a + c;\n}\n\nmodule.exports.pt = pt;\nmodule.exports.pf = pf;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/distributions-socr.js\n// module id = 128\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/distributions-socr.js?")},144:/*!************************************!*\
  !*** ./engine/regression/index.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("\n// lstsqSVD | lstsqNE\nconst METHOD = 'lstsqSVD';\n\nmodule.exports.svd = __webpack_require__(/*! ./svd-golub-reinsch */ 126);\nmodule.exports.lstsq = __webpack_require__(/*! ./lstsq */ 177)[METHOD];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/index.js\n// module id = 144\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/index.js?")},145:/*!*****************************************!*\
  !*** ./engine/statistics/metadata.json ***!
  \*****************************************/
function(module,exports){eval('module.exports = [\n\t{\n\t\t"id": "X",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "y",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "v",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "w",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "VdivwSq",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "BHat",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "yHat",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "Vary",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "nd",\n\t\t"globalOnly": true,\n\t\t"format": "int",\n\t\t"description": "Number of data (rows) in the corresponding Data Table (Fit, Cross or Validate)"\n\t},\n\t{\n\t\t"id": "np",\n\t\t"globalOnly": true,\n\t\t"format": "int",\n\t\t"description": "Number of parameters (or terms) in the Current Model"\n\t},\n\t{\n\t\t"id": "SSE",\n\t\t"sort": ">",\n\t\t"description": "Sum of squares of the residual errors"\n\t},\n\t{\n\t\t"id": "TSS",\n\t\t"globalOnly": true,\n\t\t"description": "Total sum of squares"\n\t},\n\t{\n\t\t"id": "SSR",\n\t\t"description": "Sum of squares due to regression"\n\t},\n\t{\n\t\t"id": "MSE",\n\t\t"description": "Mean square error (variance of the residual errors)"\n\t},\n\t{\n\t\t"id": "PLACEHOLDER"\n\t},\n\t{\n\t\t"id": "Rsq",\n\t\t"sort": "<",\n\t\t"description": "Square of the multiple correlation coefficient"\n\t},\n\t{\n\t\t"id": "adjRsq",\n\t\t"sort": "<",\n\t\t"description": "Adjusted R-squared - similar to Rsq, but penalizes for model complexity"\n\t},\n\t{\n\t\t"id": "PLACEHOLDER"\n\t},\n\t{\n\t\t"id": "MaxAbsErr",\n\t\t"displayName": "Max|Err|",\n\t\t"sort": ">",\n\t\t"description": "Maximum of the absolute value of the residual errors"\n\t},\n\t{\n\t\t"id": "RMSE",\n\t\t"sort": ">",\n\t\t"description": "Square root of the mean square error"\n\t},\n\t{\n\t\t"id": "SKEW",\n\t\t"sort": "<",\n\t\t"description": "Skewness"\n\t},\n\t{\n\t\t"id": "XKURT",\n\t\t"sort": "<",\n\t\t"description": "Excess kurtosis"\n\t},\n\t{\n\t\t"id": "PLACEHOLDER"\n\t},\n\t{\n\t\t"id": "AIC",\n\t\t"sort": ">",\n\t\t"description": "Akaike Information Criterion"\n\t},\n\t{\n\t\t"id": "BIC",\n\t\t"sort": ">",\n\t\t"description": "Bayesian Information Criterion"\n\t},\n\t{\n\t\t"id": "F",\n\t\t"sort": "<",\n\t\t"description": "F-statistic"\n\t},\n\t{\n\t\t"id": "pF",\n\t\t"displayName": "p(F)",\n\t\t"sort": ">",\n\t\t"description": "Probability that a larger value of the F-statistic occurs by chance. This is a test of overall model fitness."\n\t},\n\t{\n\t\t"id": "PLACEHOLDER"\n\t},\n\t{\n\t\t"id": "seSKEW",\n\t\t"displayName": "s.e. SKEW",\n\t\t"sort": "<",\n\t\t"description": "Estimated standard error of the skewness. If SKEW > 2*s.e.SKEW, there is evidence that residual errors are not normally distributed."\n\t},\n\t{\n\t\t"id": "seXKURT",\n\t\t"displayName": "s.e. XKURT",\n\t\t"sort": "<",\n\t\t"description": "Estimated standard error of the kurtosis. If |ExKurt|> 2*s.e.ExKurt, there is evidence that residual errors are not normally distributed."\n\t},\n\t{\n\t\t"id": "t",\n\t\t"sort": "|<|",\n\t\t"candidateOnly": true,\n\t\t"default": true,\n\t\t"description": "The t-statistic used to determine how significant this term is. A value above about 2.0 is usually considered significant."\n\t},\n\t{\n\t\t"id": "pt",\n\t\t"displayName": "p(t)",\n\t\t"sort": ">",\n\t\t"candidateOnly": true,\n\t\t"default": true,\n\t\t"description": "The probability that this term occurs by chance. Cell is colored green if p(t) > alpha (default alpha = 0.05)."\n\t},\n\t{\n\t\t"id": "stdev",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "mean",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "weights",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "log",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "mean",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "std",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "standardize",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "RMS",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "rescale",\n\t\t"show": false\n\t},\n\t{\n\t\t"id": "k_order_difference",\n\t\t"show": false\n\t}\n];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/metadata.json\n// module id = 145\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/metadata.json?')},175:/*!************************!*\
  !*** ./engine/perf.js ***!
  \************************/
function(module,exports,__webpack_require__){eval("\nconst utils = __webpack_require__(/*! ./utils */ 68);\nconst appStart = Date.now();\n\nif (typeof performance === 'undefined') {\n  let entries = [];\n\n  var performance = {};\n\n  function PerformanceMark(name) {\n    this.startTime = Date.now() - appStart;\n    this.duration = 0;\n    this.entryType = 'mark';\n    this.name = name;\n    entries.push(this);\n  }\n\n  function PerformanceMeasure(name, startMark, endMark) {\n    let timeNow = Date.now() - appStart;\n\n    let i = entries.length - 1;\n\n    while (i >= 0 && entries[i].name !== startMark && entries[i].type !== 'mark') {\n      i -= 1;\n    }\n    if (i >= 0) {\n      startMark = entries[i];\n    } else {\n      startMark = { startTime: 0 };\n    }\n\n    i = entries.length - 1;\n\n    while (i >= 0 && entries[i].name !== endMark && entries[i].type !== 'mark') {\n      i -= 1;\n    }\n    if (i >= 0) {\n      endMark = entries[i];\n    } else {\n      endMark = { startTime: timeNow };\n    }\n\n    this.startTime = startMark.startTime;\n    this.duration = endMark.startTime - startMark.startTime;\n    this.name = name;\n    this.entryType = 'measure';\n    entries.push(this);\n  }\n\n  performance.mark = name => {\n    new PerformanceMark(name);\n  };\n\n  performance.measure = (name, startMark, endMark) => {\n    new PerformanceMeasure(name, startMark, endMark);\n  };\n\n  performance.getEntriesByName = name => entries.filter(e => e.name === name);\n\n  performance.getEntries = () => entries.slice();\n\n  performance.getEntriesByType = type => entries.filter(e => e.entryType === type);\n}\n\nfunction start(name) {\n  performance.mark(name + ':start');\n}\n\nfunction end(name) {\n  performance.mark(name + ':end');\n  performance.measure(name + ':measure', name + ':start', name + ':end');\n}\n\nfunction getMeanDuration(name) {\n  let measures = performance.getEntriesByName(name + ':measure');\n\n  return measures.reduce((sum, measure) => sum + measure.duration, 0) / measures.length;\n}\n\nfunction log(name) {\n  let logFn = console.log;\n\n  if (console.debug) {\n    logFn = console.debug;\n  }\n\n  logFn(`[Performance] ${name}: ${getMeanDuration(name)}ms (avg)`);\n}\n\nfunction report(name, nLatestRecords = 0) {\n  let logFn = console.log;\n\n  if (console.debug) {\n    logFn = console.debug;\n  }\n\n  let measures = performance.getEntriesByName(name + ':measure').slice(-nLatestRecords);\n  let padWidth = measures.reduce((best, m) => Math.max(best, Math.floor(Math.log10(m.duration) + 1)), 0);\n\n  logFn(`[Performance] ${name} (report)`);\n  measures.forEach(measure => logFn(`  ${name}: ${utils.formatNum(padWidth, 4, measure.duration, 0)}ms`));\n}\n\nmodule.exports = { start, end, getMeanDuration, log, report };\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/perf.js\n// module id = 175\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/perf.js?")},176:/*!*********************************!*\
  !*** ./engine/matrix/Matrix.js ***!
  \*********************************/
function(module,exports,__webpack_require__){eval("\nconst utils = __webpack_require__(/*! ../utils */ 68);\n\n/**\n * Private members\n *\n * @private\n */\nconst _data = Symbol('data');\nconst _m = Symbol('m');\nconst _n = Symbol('n');\n\n// Maximum number of decimal points to print\nconst PRINT_DECIMALS = 5;\n\n// Number.MAX_SAFE_INTEGER value [ i.e. doesn't support :( ]\nconst MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Swap rows `i` and `j` in matrix `m` in place.\n *\n * @param {Matrix} m\n * @param {number} i\n * @param {number} j\n */\nfunction swapRows(m, i, j) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    temp = m[_data][j * m[_n] + k];\n    m[_data][j * m[_n] + k] = m[_data][i * m[_n] + k];\n    m[_data][i * m[_n] + k] = temp;\n  }\n}\n\n/**\n * Divide row `i` in both matrix `m` and matrix `inv` by `factor`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\nfunction divideRow(m, inv, i, factor) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    m[_data][i * m[_n] + k] /= factor;\n    inv[_data][i * m[_n] + k] /= factor;\n  }\n}\n\n/**\n * Subtract multiple of row `i` and column `j` from every row in `m` and `inv`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\nfunction subtractRowMultiple(m, inv, i, j) {\n  var k, l, factor;\n\n  for (l = 0; l < m[_m]; l += 1) {\n    factor = m[_data][l * m[_n] + j];\n\n    if (l !== i) {\n      for (k = 0; k < m[_n]; k += 1) {\n        m[_data][l * m[_n] + k] -= m[_data][i * m[_n] + k] * factor;\n        inv[_data][l * m[_n] + k] -= inv[_data][i * m[_n] + k] * factor;\n      }\n    }\n  }\n}\n\n/**\n * A speedy 2-dimensional matrix implementation.\n *\n * @class Matrix\n */\nclass Matrix {\n\n  /**\n   * Creates a new Matrix of size <n, m>, using `stuff`.\n   *\n   * If `stuff` is a Float64Array, then the reference will be used. Otherwise,\n   * its contents will be copied into a new Float64Array.\n   *\n   * @param {number | number[][]}       n     Number of columns (or nested arrays\n   *                                          that look like a matrix)\n   * @param {number}                    m     Number of rows\n   * @param {Float64Array | number[][]} stuff Items to populate the matrix\n   */\n  constructor(m, n, stuff, skip_NaN = false) {\n    if (m instanceof Matrix) {\n      return m;\n    }\n    if (Array.isArray(m)) {\n      return Matrix.from(m);\n    }\n    if (stuff != null) {\n      stuff = stuff instanceof Float64Array ? stuff : Float64Array.from(stuff);\n      if (stuff.length !== m * n) {\n        throw new Error('Array does not match the specified dimensions');\n      }\n    } else {\n      stuff = new Float64Array(m * n);\n    }\n\n    // Filter Out NaN Columns\n    let valid_columns = new Array(n).fill(true);\n    let valid_column_count = n;\n\n    //i: Iterate over columns\n    for (let i = 0; i < n; i++) {\n      // j: iterate over rows\n      for (let j = 0; j < m; j++) {\n        if (!skip_NaN && isNaN(stuff[j * n + i])) {\n          valid_columns[i] = false;\n          valid_column_count -= 1;\n          break;\n        }\n      }\n    }\n\n    // If NaN Column Found, create new Float64 Array & Populate\n    if (valid_column_count != n) {\n      let new_stuff = new Float64Array(valid_column_count * m);\n      let iterator = 0;\n      for (let i = 0; i < m * n; i++) {\n        let curr_col = i % n;\n        if (valid_columns[curr_col]) {\n          new_stuff[iterator++] = stuff[i];\n        }\n      }\n      stuff = new_stuff;\n      n = valid_column_count;\n    }\n\n    this[_data] = stuff;\n    this[_m] = m;\n    this[_n] = n;\n    return this;\n  }\n\n  /**\n   * Retrieve the element at the ith row and jth column.\n   *\n   * @param {number} i s.t. 0 <= i < m\n   * @param {number} j s.t. 0 <= i < n\n   * @return {number} Element at (i, j)\n   */\n  get(i, j) {\n    return this[_data][i * this[_n] + j];\n  }\n\n  /**\n   * Set the element at the ith row and jth column.\n   *\n   * @param {number} i s.t. 0 <= i < m\n   * @param {number} j s.t. 0 <= i < n\n   * @param {number} value To replace the existing one\n   * @return {number} Element at (i, j)\n   */\n  set(i, j, value) {\n    return this[_data][i * this[_n] + j] = value;\n  }\n\n  /**\n   * Performs element-wise addition between two matrices and returns a new copy.\n   *\n   * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n   *                                      dimensions to this\n   * @return {Matrix<m,n>} this + other\n   * @throws {Error} If dimensions do not match\n   */\n  add(other) {\n    var sum = this.clone(),\n        i;\n\n    if (typeof other === 'number') {\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] += other;\n      }\n    } else {\n      if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m] + ' && ' + this[_m] + ' !== ' + other[_m]);\n      }\n\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] += other[_data][i];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Performs element-wise subtraction between two matrices and returns a new\n   * copy.\n   *\n   * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n   *                                      dimensions to this\n   * @return {Matrix<m,n>} this - other\n   * @throws {Error} If dimensions do not match\n   */\n  sub(other) {\n    var sum = this.clone(),\n        i;\n\n    if (typeof other === 'number') {\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] -= other;\n      }\n    } else {\n      if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m] + ' && ' + this[_m] + ' !== ' + other[_m]);\n      }\n\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] -= other[_data][i];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Performs matrix multiplication between this and other.\n   *\n   * @param {Matrix<n,k>} other Matrix whose rows must be === to this's columns\n   * @return {Matrix<m,k>} this * other\n   * @throws {Error} If dimensions do not match\n   */\n  dot(other) {\n    if (this[_n] !== other[_m]) {\n      throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m]);\n    }\n\n    var product = new Matrix(this[_m], other[_n]),\n        i,\n        j,\n        k,\n        sum;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < other[_n]; j += 1) {\n        for (k = 0, sum = 0; k < this[_n]; k += 1) {\n          sum += this[_data][i * this[_n] + k] * other[_data][k * other[_n] + j];\n        }\n        product[_data][i * other[_n] + j] = sum;\n      }\n    }\n    return product;\n  }\n\n  /**\n   * Computes the inverse of the matrix (only if it is square!).\n   *\n   * @return {Matrix<m,n>} Inverse matrix s.t. this * inv(this) === I\n   * @throws {Error} If not a square matrix\n   */\n  inv() {\n    if (this[_m] !== this[_n]) {\n      throw new Error('Must be square');\n    }\n\n    var self = this.clone(),\n        inverse = Matrix.eye(this[_m], this[_n]),\n        i,\n        j,\n        k,\n        factor;\n\n    for (i = 0, j = 0; i < self[_m] && j < self[_n]; i += 1, j += 1) {\n      if (self[_data] === 0) {\n        for (k = 0; self[_data][k * self[_n] + j] !== 0 && k < self[_m]; k += 1);\n        if (k >= self[_m]) {\n          j += 1;\n          continue;\n        }\n        swapRows(self, j, k);\n        swapRows(inverse, j, k);\n      }\n      divideRow(self, inverse, j, self[_data][j * self[_n] + j]);\n      subtractRowMultiple(self, inverse, i, j);\n    }\n    return inverse;\n  }\n\n  /**\n   * Returns a copy of the matrix.\n   *\n   * @return {Matrix<m,n>} Fresh clone\n   */\n  clone() {\n    return new Matrix(this[_m], this[_n], this[_data].slice());\n  }\n\n  /**\n   * Horizontally stacks `other` and returns the new matrix.\n   *\n   * @param {Matrix<m,k>} other Matrix whose rows === this's rows\n   * @return {Matrix<m,n+k>} Horizontal concatenation of this and other\n   * @throws {Error} If dimensions do not match\n   */\n  hstack(other) {\n    if (this[_m] !== other[_m]) {\n      throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_m] + ' !== ' + other[_m]);\n    }\n\n    var newM = this[_n] + other[_n],\n        stacked = new Matrix(this[_m], newM),\n        i,\n        j;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < this[_n]; j += 1) {\n        stacked[_data][i * newM + j] = this[_data][i * this[_n] + j];\n      }\n      for (j = 0; j < other[_n]; j += 1) {\n        stacked[_data][i * newM + this[_n] + j] = other[_data][i * other[_n] + j];\n      }\n    }\n    return stacked;\n  }\n\n  /**\n   * Vertically stacks `other` and returns the new matrix.\n   *\n   * @param {Matrix<k,n>} other Matrix whose cols === this's cols\n   * @return {Matrix<m+k,n>} Vertical concatenation of this and other\n   * @throws {Error} If dimensions do not match\n   */\n  vstack(other) {\n    if (this[_n] !== other[_n]) {\n      throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_n]);\n    }\n\n    var stacked = new Matrix(this[_m] + other[_m], this[_n]);\n\n    stacked[_data].subarray(0, this[_m] * this[_n]).set(this[_data]);\n    stacked[_data].subarray(this[_m] * this[_n]).set(other[_data]);\n    return stacked;\n  }\n\n  /**\n   * Performs element-wise exponentiation to the matrix and returns a new copy.\n   *\n   * @param {number} exponent Power to raise each element to\n   * @return {Matrix<m,n>} this[i,i]^exponent\n   */\n  dotPow(exponent) {\n    var powd = this.clone(),\n        i;\n\n    for (i = 0; i < powd[_data].length; i += 1) {\n      powd[_data][i] = Math.pow(powd[_data][i], exponent);\n      if (!Number.isFinite(powd[_data][i])) {\n        powd[_data][i] = MAX_SAFE_INTEGER;\n      }\n    }\n    return powd;\n  }\n\n  /**\n   * Performs element-wise multiplication to the matrix and returns a new copy.\n   *\n   * @param {number | Matrix} n Multiplicand to multiply each element by, or a\n   *                            matrix whose elements will be iterated through\n   *                            in alignment with this\n   * @return {Matrix<m,n>} this[i,i] * n   OR   this[i,i] * n[i,i]\n   */\n  dotMultiply(n) {\n    var product = this.clone(),\n        i;\n\n    if (typeof n === 'number') {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] * n;\n      }\n    } else if (n instanceof Matrix) {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] * n[_data][i];\n      }\n    }\n    return product;\n  }\n\n  /**\n   * Performs element-wise division to the matrix and returns a new copy.\n   *\n   * @param {number | Matrix} n Divisor to divide each element by, or a matrix\n   *                            whose elements will be iterated through in\n   *                            alignment with this\n   * @return {Matrix<m,n>} this[i,i] / n   OR   this[i,i] / n[i,i]\n   */\n  dotDivide(n) {\n    var product = this.clone(),\n        i,\n        j;\n\n    if (typeof n === 'number') {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] / n;\n      }\n    } else if (n instanceof Matrix) {\n      for (i = 0, j = 0; i < product[_data].length; i += 1, j += 1) {\n        if (j >= n[_data].length) {\n          j = 0;\n        }\n        product[_data][i] = product[_data][i] / n[_data][j];\n      }\n    }\n    return product;\n  }\n\n  log() {\n    var product = this.clone(),\n        i;\n\n    for (i = 0; i < product[_data].length; i += 1) {\n      product[_data][i] = Math.log10(product[_data][i]);\n    }\n    return product;\n  }\n\n  appendM(m) {\n    var matrix_dim = m.shape,\n        rows = this[_m],\n        cols = this[_n] + matrix_dim[1],\n        append_matrix = new Matrix(rows, cols),\n        i,\n        j;\n\n    for (i = 0; i < rows; i += 1) {\n      for (j = 0; j < cols; j += 1) {\n        var use_m = j - this[_n];\n        var data_pt = use_m >= 0 ? m[_data][i * matrix_dim[1] + use_m] : this[_data][i * this[_n] + j];\n        append_matrix[_data][i * cols + j] = data_pt;\n      }\n    }\n    return append_matrix;\n  }\n\n  /**\n   * @see inspect\n   */\n  toString() {\n    return this.inspect();\n  }\n\n  /**\n   * Converts to nested array format\n   *\n   * @return {[][]} Nested arrays, where each child array is a row\n   */\n  toJSON() {\n    let i, rows;\n\n    for (i = 1, rows = []; i <= this[_m]; i += 1) {\n      rows.push(Array.from(this[_data].slice((i - 1) * this[_n], i * this[_n])));\n    }\n    return rows;\n  }\n\n  /**\n   * Stringifies the matrix into a pretty format\n   *\n   * @return {string} Representation of the matrix\n   */\n  inspect(depth, options = { stylize: x => '' + x }) {\n    var repr = options.stylize(this.constructor.name, 'none'),\n        strings = Array.from(this[_data]).map(i => ('' + i).match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/)),\n        lwidth = Math.max.apply(null, strings.map(match => match[1].length)),\n        rwidth = Math.min(Math.max.apply(null, strings.map(match => match[2].length)), PRINT_DECIMALS),\n        rows = [],\n        i;\n\n    strings = Array.from(this[_data]).map(n => options.stylize(utils.formatNum(lwidth, rwidth, n), 'number'));\n\n    for (i = 0; i < this[_m]; i += 1) {\n      rows.push('[ ' + strings.slice(i * this[_n], (i + 1) * this[_n]).join(', ') + ' ]');\n    }\n\n    return repr + ' ' + utils.padAll(this.constructor.name.length + 1, rows.join('\\n')).trim();\n  }\n\n  /**\n   * Retrieves/sets the ith column of the matrix\n   *\n   * @param {number}    i         Column index\n   * @param {number[]}  [newCol]  Elements to replace the col with\n   * @return {Matrix<m,1>} Column as a matrix\n   */\n  col(i, newCol) {\n    var theCol = new Matrix(this[_m], 1),\n        k;\n\n    if (newCol != null) {\n      if (newCol.length > this[_m]) {\n        throw new RangeError('newCol cannot be longer than ' + this[_m]);\n      }\n      for (k = 0; k < this[_m]; k += 1) {\n        this[_data][k * this[_n] + i] = newCol[k];\n      }\n    }\n\n    for (k = 0; k < this[_m]; k += 1) {\n      theCol[_data][k] = this[_data][k * this[_n] + i];\n    }\n    return theCol;\n  }\n\n  /**\n   * Retrieves/sets the ith row of the matrix\n   *\n   * @param {number}    i         Row index\n   * @param {number[]}  [newRow]  Elements to replace the row with\n   * @return {Matrix<1,n>} Row as a matrix\n   */\n  row(i, newRow) {\n    if (newRow != null) {\n      if (newRow.length > this[_n]) {\n        throw new RangeError('newRow cannot be longer than ' + this[_n]);\n      }\n      this[_data].subarray(i * this[_n]).set(newRow);\n    }\n    return new Matrix(1, this[_n], this[_data].slice(i * this[_n], (i + 1) * this[_n]));\n  }\n\n  /**\n   * Retrieves a subset of the matrix, constructed from indices in `rows` and\n   * `cols`. The resulting matrix will have rows s.t. result[i] = this[rows[i]]\n   * and columns s.t. result[i][j] = this[rows[i][cols[j]]]\n   *\n   * @param {number[]} rows Array of indices used to construct the subset\n   * @param {number[]} cols Array of indices used to construct the subset\n   * @return {Matrix<rows.length, cols.length>} Subset of this\n   */\n  subset(rows = ':', cols = ':') {\n    rows = utils.convertRange(rows, this[_m]);\n    cols = utils.convertRange(cols, this[_n]);\n\n    var subMatrix = new Matrix(rows.length, cols.length),\n        i,\n        j;\n\n    for (i = 0; i < rows.length; i += 1) {\n      for (j = 0; j < cols.length; j += 1) {\n        subMatrix[_data][i * subMatrix[_n] + j] = this[_data][rows[i] * this[_n] + cols[j]];\n      }\n    }\n    return subMatrix;\n  }\n\n  // Create subset of data with row-end\n  lo(row = 0) {\n    return new Matrix(this[_m] - row, this[_n], this[_data].slice(row * this[_n]));\n  }\n\n  // Create a subset of data withs rows 0-row\n  hi(row = 0) {\n    return new Matrix(row, this[_n], this[_data].slice(0, row * this[_n]));\n  }\n\n  // Function removes column from matrix\n  delColumn(col = 0) {\n    var columns = this[_n];\n    return new Matrix(this[_m], this[_n] - 1, this[_data].filter(function (_, i) {\n      return i % columns !== col;\n    }));\n  }\n\n  // TODO: document\n  shift(rows) {\n    let newData = new Float64Array(this[_m] * this[_n]);\n    newData.subarray(this[_n] * rows).set(this[_data].subarray(0, -(this[_n] * rows) || this[_data].length));\n    return new Matrix(this[_n], this[_m], newData);\n  }\n\n  /**\n   * Retrieves the diagonal elements as a 1 x min(m, n) matrix.\n   *\n   * @return {Matrix<1,min(m,n)>} Diagonal elements\n   */\n  diag() {\n    var diagonal = new Matrix(1, Math.min(this[_m], this[_n])),\n        i;\n\n    for (i = 0; i < this[_m] && i < this[_n]; i += 1) {\n      diagonal[_data][i] = this[_data][i * this[_n] + i];\n    }\n    return diagonal;\n  }\n\n  /**\n   * Performs `Math.abs()` on each element then returns the resulting matrix.\n   *\n   * @return {Matrix<m,n>} A clone of `this`, but with the absolute value of\n   *                       each element\n   */\n  abs() {\n    var absolute = this.clone(),\n        i;\n\n    for (i = 0; i < absolute[_data].length; i += 1) {\n      absolute[_data][i] = Math.abs(absolute[_data][i]);\n    }\n    return absolute;\n  }\n\n  /**\n   * Sums all of the elements.\n   *\n   * @return {number} Sum of all of the elements\n   */\n  sum() {\n    var tot = 0,\n        i;\n\n    for (i = 0; i < this[_data].length; i += 1) {\n      tot += this[_data][i];\n    }\n    return tot;\n  }\n\n  /**\n   * Takes the product of all elements.\n   *\n   * @return {number} Product of all elements\n   */\n  prod() {\n    var tot = 1,\n        i;\n\n    for (i = 0; i < this[_data].length; i += 1) {\n      tot *= this[_data][i];\n    }\n    return tot;\n  }\n\n  /**\n   * Get minimum value in matrix\n   *\n   * @return {number} Minimum value\n   */\n  min() {\n    let i, min;\n\n    for (i = 0, min = Infinity; i < this[_data].length; i += 1) {\n      min = Math.min(min, this[_data][i]);\n    }\n    return min;\n  }\n\n  /**\n   * Get maximum value in matrix\n   *\n   * @return {number} Maximum value\n   */\n  max() {\n    let i, max;\n\n    for (i = 0, max = -Infinity; i < this[_data].length; i += 1) {\n      max = Math.max(max, this[_data][i]);\n    }\n    return max;\n  }\n\n  /**\n   * @property {Matrix<n,m>} T The transposition of the matrix\n   */\n  get T() {\n    var transpose = new Matrix(this[_n], this[_m]),\n        i,\n        j;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < this[_n]; j += 1) {\n        transpose[_data][j * this[_m] + i] = this[_data][i * this[_n] + j];\n      }\n    }\n    return transpose;\n  }\n\n  /**\n   * @property {[number, number]} shape The shape of this matrix [m, n]\n   */\n  get shape() {\n    return [this[_m], this[_n]];\n  }\n\n  /**\n   * @property {Float64Array} data The underlying storage for the matrix\n   */\n  get data() {\n    return this[_data];\n  }\n\n  /**\n   * Generates a matrix full of random (0, 1) numbers.\n   *\n   * @static\n   * @return {Matrix<m,n>} Matrix full'a random numbas\n   */\n  static random(m, n) {\n    var randMatrix = new Matrix(m, n),\n        i,\n        j;\n\n    for (i = 0; i < m; i += 1) {\n      for (j = 0; j < n; j += 1) {\n        randMatrix[_data][i * n + j] = Math.random();\n      }\n    }\n    return randMatrix;\n  }\n\n  /**\n   * Generates a matrix whose diagonal elements equal 1.\n   *\n   * @static\n   * @return {Matrix<m,n>} Diagonal onez\n   */\n  static eye(m, n = m) {\n    var onez = new Matrix(m, n),\n        i,\n        j;\n\n    for (i = 0; i < m; i += 1) {\n      onez[_data][i * n + i] = 1;\n    }\n    return onez;\n  }\n\n  /**\n   * Creates a matrix from matrix-looking nested arrays, or a flat array and the\n   * given `m` and `n`.\n   *\n   * @param {iterable | Matrix} arr Values to populate the matrix with\n   * @param {number}            m   Rows in the new matrix\n   * @param {number}            n   Columns in the new matrix\n   */\n  static from(arr, m, n) {\n    if (arr instanceof Matrix) {\n      return arr.clone();\n    }\n    if (!Array.isArray(arr)) {\n      throw new TypeError('Expected an array or Matrix');\n    }\n    if (arr.length <= 0) {\n      return new Matrix(0, 0);\n    }\n\n    var i;\n\n    m = m || arr.length;\n    n = n || arr[0].length;\n\n    // handed a 1-d array\n    if (arr[0].length == null) {\n      return new Matrix(1, arr.length, Float64Array.from(arr));\n    }\n\n    // otherwise, it's a 2-d array (and hopefully not >2-d)\n    for (i = 0; i < arr.length; i += 1) {\n      if (arr[i].length !== n) {\n        throw new Error('All rows must have equal length');\n      }\n    }\n    return new Matrix(m, n, Float64Array.from(utils.join(arr)));\n  }\n\n  /**\n   * Creates a matrix using `arr` to fill the diagonal elements in order.\n   *\n   * @param {number[m]} arr Array of numbers\n   * @returns {Matrix<m,m>} Matrix consisting only of the diagonal elements\n   */\n  static diag(arr) {\n    var m = arr.length,\n        mat = new Matrix(m, m),\n        i;\n\n    for (i = 0; i < m; i += 1) {\n      mat.data[i * m + i] = arr[i];\n    }\n    return mat;\n  }\n\n  static zeros(m, n = m) {\n    return this.eye(m, n).dotMultiply(0);\n  }\n\n}\n\nmodule.exports = Matrix;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/Matrix.js\n// module id = 176\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/matrix/Matrix.js?")},177:/*!************************************!*\
  !*** ./engine/regression/lstsq.js ***!
  \************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Matrix = __webpack_require__(/*! ../matrix */ 65);\nconst svd = __webpack_require__(/*! ./svd-golub-reinsch */ 126);\nconst statistics = __webpack_require__(/*! ../statistics */ 112);\nconst dist = __webpack_require__(/*! ../statistics/distributions-socr */ 128);\nconst utils = __webpack_require__(/*! ../utils */ 68);\n\n/**\n * Computes total least squares regression on the matrix `A`, already decomposed\n * using SVD into the constituent `U`, `S` (sigma), and `V` matrices.\n *\n * @param {Matrix<m,n>} A Data matrix\n * @param {Matrix<m,m>} U U matrix resulting from SVD\n * @param {Matrix<m,n>} S Diagonal sigma matrix resulting from SVD\n * @param {Matrix<n,n>} V V matrix resulting from SVD\n * @param {Matrix<m,1>} b Independent column\n * @return {Matrix<n,1>} Estimated weight vector for the parameters (cols) in A\n */\nfunction lstsqSVD(A, U, S, V, b) {\n  var s = S,\n      m = A.shape[0],\n      n = A.shape[1],\n      eps = Number.EPSILON,\n      efcols = [],\n      maxEig = Math.max.apply(null, s.data),\n      i,\n      d,\n      x;\n\n  for (i = 0; i < n; i++) {\n    if (s.data[i] < Math.max(m, n) * eps * maxEig) {\n      s.data[i] = 0;\n    }\n  }\n  d = U.T.dot(b);\n  d = d.dotDivide(s);\n  for (i = 0; i < n; i++) {\n    if (Math.abs(d.data[i]) === Infinity) {\n      d.data[i] = 0;\n    }\n  }\n  x = V.dot(d);\n  return x;\n}\n\n/**\n * Compute least squares regression using normal equations, then compute\n * analytical statistics to determine the quality of the fit for the model and\n * for each term in the model.\n *\n *    B'      = inv(X'X)X'y                       <-- weight vector\n *    y'      = XB'\n *\n *    Nd      = # of data\n *    Np      = # of params (coefs) in model\n *\n *    SSE     = sum((y - y')^2)                   ^2 is element-wise\n *    TSS     = sum((y - mean(y))^2)\n *    SSR     = TSS - SSE\n *    Var y   = TSS / (Nd - 1)\n *    MSR     = SSR / (Np - 1)\n *    MSE     = SSE / (Nd - Np)\n *    RSQ     = 1 - (SSE / TSS)\n *    cRSQ    = 1 - R^2\n *    adj-RSQ = 1 - (MSE / Var y)\n *    F       = MSR / MSE\n *    AIC     = log(MSE) + 2*(Np/Nd)\n *    BIC     = log(MSE) + Np*log(Nd)/Nd\n *    t_i     = B' / sqrt( inv(X'X)[i,i] * MSE )   / is element-wise\n *    SKEW    = sum((y-y')^3/N/s^3)\n *    XKURT    = sum((y-y')^4/N/s^4)\n *\n * @return {object} Regression results\n */\nfunction lstsqNEWithStats(X, y) {\n  var XT = X.T,\n      pseudoInverse = XT.dot(X).inv(),\n      BHat = pseudoInverse.dot(XT).dot(y),\n      yHat = X.dot(BHat)\n\n  // fit statistics\n  ,\n      nd = X.shape[0],\n      np = X.shape[1],\n      sse = y.sub(yHat).dotPow(2).sum(),\n      tss = y.sub(y.sum() / y.shape[0]).dotPow(2).sum(),\n      ssr = tss - sse,\n      vary = tss / (nd - 1),\n      msr = ssr / (np - 1),\n      mse = sse / (nd - np),\n      rsq = 1 - sse / tss,\n      adjrsq = 1 - mse / vary,\n      f = msr / mse,\n      aic = Math.log10(mse) + 2 * (np / nd),\n      bic = Math.log10(mse) + np * (Math.log10(nd) / nd)\n\n  // for t-statistics\n  ,\n      rtmse = Math.sqrt(mse),\n      sec = pseudoInverse.diag().abs().dotPow(0.5).dotMultiply(rtmse),\n      tstats = BHat.dotDivide(sec),\n      pts = tstats.clone();\n\n  pts.data.set(pts.data.map(t => dist.pt(t, nd - np)));\n\n  return {\n    weights: BHat,\n    tstats: tstats,\n    mse: mse,\n    rsq: rsq,\n    adjrsq: adjrsq,\n    f: f,\n    pf: dist.pf(f, np, nd - np),\n    aic: aic,\n    bic: bic,\n    pts: pts\n  };\n}\n\nfunction scale(X) {\n  let stdevs = [];\n  let means = [];\n  let intercept = -1;\n  let i;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    let col = X.col(i);\n    let nd = col.shape[0];\n    let mean = col.sum() / nd;\n    let newCol = col.sub(mean);\n    let stdev = Math.sqrt(newCol.dotPow(2).sum() / (nd - 1));\n\n    means.push(mean);\n\n    if (stdev <= Number.EPSILON && mean === 1) {\n      stdevs.push(1);\n      intercept = i;\n    } else {\n      X.col(i, newCol.dotDivide(stdev).data);\n      stdevs.push(stdev);\n    }\n  }\n\n  return {\n    stdev: new Matrix(stdevs).T,\n    mean: new Matrix(means).T,\n    intercept\n  };\n}\n\n/**\n * Compute least squares regression using singular value decomposition, then\n * compute analytical statistics to determine the quality of the fit for the\n * model and for each term in the model.\n *\n *    U, s, V = svd(X)\n *    B'      = V(U'b ./ s)                       See svd.lstsq for more\n *    y'      = XB'\n *\n * @return {object} Regression results\n */\nfunction lstsqSVDWithStats(X, y, predictors) {\n  let i;\n  let stdev = 1,\n      mean = 0,\n      intercept = -1;\n  //let { stdev, mean, intercept } = scale(X);\n\n  let decomposition = svd(X),\n      U = decomposition[0],\n      w = Matrix.from(decomposition[1]),\n      V = decomposition[2],\n      VdivwSq = V.dotDivide(w).dotPow(2),\n      BHat = predictors || lstsqSVD(X, U, w, V, y),\n      weights = BHat.dotDivide(stdev);\n\n  // If there is an intercept, un-scale its weight by subtracting the means of\n  // the other columns times the corresponding sign of their weights\n  //\n  //          B_0 = B_0 - sum(mean(i) * sign(weights(i)))\n  //\n  if (intercept >= 0) {\n    let interceptWeight = weights.get(0, intercept) + 1;\n\n    for (i = 0; i < weights.shape[0]; i += 1) {\n      interceptWeight -= mean.data[i] * utils.sign(weights.data[i]);\n    }\n    weights.data[intercept] = interceptWeight;\n  }\n\n  // Remove infinitely high values to work around potential divide-by-zero issue\n  for (i = 0; i < VdivwSq.data.length; i += 1) {\n    if (Math.abs(VdivwSq.data[i]) === Infinity || isNaN(VdivwSq.data[i])) {\n      VdivwSq.data[i] = 0;\n    }\n  }\n\n  return { X, y, BHat, VdivwSq, stdev, mean, weights, V, w };\n}\n\nmodule.exports.lstsqSVD = lstsqSVDWithStats;\nmodule.exports.lstsqNE = lstsqNEWithStats;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/lstsq.js\n// module id = 177\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/lstsq.js?")},178:/*!******************************************!*\
  !*** ./engine/statistics/definitions.js ***!
  \******************************************/
function(module,exports,__webpack_require__){eval("\nconst Statistic = __webpack_require__(/*! ./Statistic */ 127);\nconst Matrix = __webpack_require__(/*! ../matrix */ 65);\nconst dist = __webpack_require__(/*! ./distributions-socr */ 128);\n\n// Functional definitions for statistics -- defines how they will be calculated\n// NOTE: Make sure each statistic has an entry in `metadata.json`\nmodule.exports = [\n// given\nStatistic('X', [], ({ X }) => X), Statistic('y', [], ({ y }) => y), Statistic('BHat', [], ({ BHat }) => BHat), Statistic('yHat', ['X', 'BHat'], ({ X, BHat }) => X.dot(BHat)),\n\n// fit statistics\nStatistic('nd', ['X'], ({ X }) => X.shape[0]), Statistic('np', ['X'], ({ X }) => X.shape[1]), Statistic('SSE', ['y', 'yHat'], ({ y, yHat }) => y.sub(yHat).dotPow(2).sum()), Statistic('TSS', ['y'], ({ y }) => y.sub(y.sum() / y.shape[0]).dotPow(2).sum()),\n\n// yHat.sub(y.sum() / y.shape[0]).dotPow(2).sum()));\nStatistic('SSR', ['TSS', 'SSE'], ({ TSS, SSE }) => TSS - SSE), Statistic('Vary', ['TSS', 'nd'], ({ TSS, nd }) => TSS / (nd - 1)), Statistic('MSR', ['SSR', 'np'], ({ SSR, np }) => SSR / (np - 1)), Statistic('SKEW', ['y', 'yHat', 'nd'], ({ y, yHat, nd }) => {\n  let residuals = y.sub(yHat);\n  let residMean = residuals.sum() / residuals.shape[0];\n  let residStDv = Math.sqrt(residuals.sub(residMean).dotPow(2).sum() / (nd - 1));\n\n  return nd * residuals.sub(residMean).dotPow(3).sum() / (nd - 1) / (nd - 2) / residStDv / residStDv / residStDv;\n}), Statistic('XKURT', ['y', 'yHat', 'nd'], ({ y, yHat, nd }) => {\n  let residuals = y.sub(yHat);\n  let residMean = residuals.sum() / residuals.shape[0];\n  let residStDv = Math.sqrt(residuals.sub(residMean).dotPow(2).sum() / (nd - 1));\n\n  // let r1 =  nd * (nd + 1) *residuals.sub(residMean).dotPow(4).sum() / (nd - 1) / (nd - 2) / (nd - 3) / residStDev / residStDv / residStDv / residStdDv;\n  let r1 = nd * (nd + 1) * residuals.sub(residMean).dotPow(4).sum() / (nd - 1) / (nd - 2) / (nd - 3) / residStDv / residStDv / residStDv / residStDv;\n\n  let r2 = 3 * (nd - 1) * (nd - 1) / (nd - 2) / (nd - 3);\n  return r1 - r2;\n}), Statistic('seSKEW', ['nd'], ({ nd }) => Math.sqrt(6 / nd)), Statistic('seXKURT', ['nd'], ({ nd }) => Math.sqrt(24 / nd)), Statistic('MSE', ['SSE', 'nd', 'np'], ({ SSE, nd, np }) => SSE / (nd - np)), Statistic('RMSE', ['MSE'], ({ MSE }) => Math.sqrt(MSE)), Statistic('Rsq', ['SSE', 'TSS'], ({ SSE, TSS }) => 1 - SSE / TSS), Statistic('adjRsq', ['Rsq', 'np', 'nd'], ({ Rsq, nd, np }) => 1 - (1 - Rsq) * (nd - 1) / (nd - np)), Statistic('F', ['MSR', 'MSE'], ({ MSR, MSE }) => MSR / MSE), Statistic('AIC', ['MSE', 'np', 'nd'], ({ MSE, np, nd }) => Math.log10(MSE) + 2 * (np / nd)), Statistic('BIC', ['MSE', 'np', 'nd'], ({ MSE, np, nd }) => Math.log10(MSE) + np * (Math.log10(nd) / nd)), Statistic('MaxAbsErr', ['y', 'yHat'], ({ y, yHat }) => y.sub(yHat).abs().max()), Statistic('t', ['X', 'VdivwSq', 'MSE', 'BHat'], ({ X, VdivwSq, MSE, BHat }) => {\n  var sec = new Matrix(1, X.shape[1]),\n      stdModelErr,\n      i;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    stdModelErr = Math.sqrt(VdivwSq.row(i).sum() * MSE);\n    sec.data[i] = stdModelErr;\n  }\n\n  return BHat.dotDivide(sec);\n}), Statistic('pt', ['t', 'np', 'nd'], ({ t, np, nd }) => {\n  let pt = t.clone();\n  pt.data.set(pt.data.map(t => Math.max(0, dist.pt(t, nd - np))));\n  return pt;\n}), Statistic('pF', ['F', 'np', 'nd'], ({ F, np, nd }) => Math.max(dist.pf(Math.abs(F), np, nd - np) - 1e-15, 0)), Statistic('log', [\"X\"], ({ X }) => X.log()), Statistic('mean', [\"X\"], ({ X }) => {\n  return X.data.reduce((total, c) => total += c, 0) / X.data.length;\n}), Statistic('std', [\"X\", \"mean\"], ({ X, mean }) => {\n  let diff = X.data.map(d => Math.pow(d - mean, 2));\n  let diff_total = diff.reduce((total, c) => total += c, 0);\n  return Math.sqrt(diff_total / X.data.length);\n}), Statistic('standardize', [\"X\", \"mean\", \"std\"], ({ X, mean, std }) => {\n  let standardize = X.clone();\n  standardize.data.set(standardize.data.map(d => (d - mean) / std));\n  return standardize;\n}), Statistic('RMS', [\"X\"], ({ X }) => {\n  let rms = X.clone();\n  let SS = rms.data.map(r => Math.pow(r, 2)).reduce((total, xi) => total += xi, 0);\n  return Math.sqrt(SS / rms.data.length);\n}), Statistic('rescale', [\"X\", \"RMS\"], ({ X, RMS }) => {\n  let rescale = X.clone();\n  rescale.data.set(rescale.data.map(d => d / RMS));\n  return rescale;\n}), Statistic('k_order_difference', [\"X\", \"k\"], ({ X, k }) => {\n  let k_order_func = (data, k) => {\n    if (k == 1) {\n      return data.map((d, idx) => idx < k ? null : d - data[idx - 1]);\n    } else {\n      k_1_order = k_order_func(data, k - 1);\n      return data.map((_, idx) => idx < k ? null : k_1_order[idx] - k_1_order[idx - 1]);\n    }\n  };\n  if (!k || isNaN(k)) {\n    return X;\n  }\n  let k_order = X.clone();\n  k_order.data.set(k_order_func(k_order.data, k));\n  return k_order;\n}), Statistic('sensitivity_part', ['data', 'exp', 'derivative'], ({ data, exp, derivative }) => {\n  if (data == undefined) {\n    return -1;\n  }\n\n  if (derivative) {\n    return data.map(x => exp * Math.pow(x, exp - 1));\n  } else {\n    return data.map(x => Math.pow(x, exp));\n  }\n})];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/definitions.js\n// module id = 178\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/definitions.js?")},179:/*!**************************************!*\
  !*** ./engine/statistics/topsort.js ***!
  \**************************************/
function(module,exports){eval("\nconst inDegree = (stat, statistics) => {\n  let names = statistics.map(({ name }) => name);\n  return stat.args.filter(s => names.includes(s)).length;\n};\n\nconst topsort = statistics => {\n  let S = statistics.filter(stat => stat.args.length === 0);\n  let L = [];\n  let remaining = statistics.filter(stat => !S.includes(stat));\n  let node;\n\n  while (S.length > 0) {\n    node = S.shift();\n    remaining = remaining.filter(n => n !== node);\n    L.push(node);\n    S = S.concat(remaining.filter(stat => inDegree(stat, remaining) === 0));\n    remaining = remaining.filter(stat => !S.includes(stat));\n  }\n  if (remaining.length > 0) {\n    throw new Error('Statistics are co-dependent');\n  }\n  return L;\n};\n\nmodule.exports = topsort;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/topsort.js\n// module id = 179\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/topsort.js?")},229:/*!************************************!*\
  !*** ./engine/model/CacheMixin.js ***!
  \************************************/
function(module,exports){eval("\nconst _cache = Symbol('cache');\nconst _mixinref = Symbol('CacheMixin_ref');\n\nconst CacheMixin = (superclass = class {}) => class extends superclass {\n\n  constructor() {\n    super(...arguments);\n    this[_cache] = {};\n  }\n\n  uncache(functionName, ...args) {\n    let argsKey = args.toString();\n\n    if (functionName == null) {\n      this[_cache] = {};\n      return this;\n    }\n\n    if (this[_cache][functionName] == null) {\n      return this;\n    }\n\n    if (args.length <= 0) {\n      this[_cache][functionName] = {};\n      return this;\n    }\n\n    let { defaultArgs, originalLength } = this[functionName];\n\n    args = args.concat(defaultArgs.slice(args.length));\n    args.length = originalLength + defaultArgs.length;\n\n    delete this[_cache][functionName][args.toString()];\n    return this;\n  }\n\n  static get [_mixinref]() {\n    return true;\n  }\n\n};\n\n// Static function that should be used to specify functions to apply caching to\nCacheMixin.cache = (clazz, functionName, defaultArgs = []) => {\n  let originalFunction = clazz.prototype[functionName];\n\n  if (clazz[_mixinref] !== true) {\n    throw new TypeError('Class must extend CacheMixin');\n  }\n\n  if (originalFunction == null) {\n    throw new ReferenceError(`${clazz.name}.prototype.${functionName} is not a function`);\n  }\n\n  // Overwrite prototype definition with wrapper that caches results\n  clazz.prototype[functionName] = function () {\n    let args = Array.prototype.slice.apply(arguments).concat(defaultArgs.slice(arguments.length));\n    args.length = originalFunction.length + defaultArgs.length;\n\n    let argsKey = args.toString();\n\n    if (this[_cache][functionName] == null) {\n      this[_cache][functionName] = {};\n    }\n\n    if (argsKey in this[_cache][functionName]) {\n      return this[_cache][functionName][argsKey];\n    }\n    this[_cache][functionName][argsKey] = originalFunction.apply(this, args);\n    return this[_cache][functionName][argsKey];\n  };\n\n  // Expose default arguments and original function length for use later on\n  clazz.prototype[functionName].defaultArgs = defaultArgs;\n  clazz.prototype[functionName].originalLength = originalFunction.length;\n};\n\nmodule.exports = CacheMixin;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/CacheMixin.js\n// module id = 229\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/CacheMixin.js?")},342:/*!*******************************!*\
  !*** ./engine/model/index.js ***!
  \*******************************/
function(module,exports,__webpack_require__){eval("\nmodule.exports = __webpack_require__(/*! ./Model */ 349);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/index.js\n// module id = 342\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/index.js?")},348:/*!*****************************************!*\
  !*** ./engine/model/CandidateWorker.js ***!
  \*****************************************/
function(module,exports,__webpack_require__){eval("/*global Worker*/\n\nconst { FIT_LABEL, CROSS_LABEL, VALIDATION_LABEL } = __webpack_require__(/*! ../labels.json */ 66);\n//const CandidateWorkerScript       = require('../worker/candidate-worker.js');\nconst perf = __webpack_require__(/*! ../perf */ 175);\n\nconst randomId = () => Math.floor(Math.random() * 1e16).toString(16);\n\nlet counter = (() => {\n  let next = 0;\n  return () => next += 1;\n})();\n\nfunction unwrapMatrix(matrix) {\n  return {\n    m: matrix.shape[0],\n    n: matrix.shape[1],\n    data: matrix.data\n  };\n}\n\nclass CandidateWorker {\n\n  constructor(model) {\n    if (typeof Worker === 'undefined' || !Worker) {\n      throw new Error('Web workers unavailable');\n    }\n    this.id = counter();\n    this.worker = new Worker('candidate-worker.js');\n    this.model = model;\n  }\n\n  compute(candidates, update) {\n    let thisJobId = randomId();\n\n    return new Promise((resolve, reject) => {\n      this.worker.addEventListener('message', ({ data: { data, type, jobId } }) => {\n        if (jobId !== thisJobId) {\n          return;\n        }\n\n        switch (type) {\n          case 'progress':\n            update && update(this.id, data);\n            break;\n\n          case 'result':\n            resolve(data.map((stats, i) => ({\n              term: candidates[i].valueOf(),\n              coeff: stats.coeff,\n              stats\n            })));\n            perf.end('candidate-worker');\n            break;\n\n          default:\n            console.error(`[CandidateWorker${this.id}]: Invalid type '${type}'`);\n            break;\n        }\n      });\n      perf.start('candidate-worker');\n\n      // 2d array of each column and its values\n      let transferables = [];\n\n      let fit = {\n        X: unwrapMatrix(this.model.X(FIT_LABEL)),\n        y: unwrapMatrix(this.model.y(FIT_LABEL))\n      };\n\n      let cross;\n      let validation;\n      try {\n        cross = {\n          X: unwrapMatrix(this.model.X(CROSS_LABEL)),\n          y: unwrapMatrix(this.model.y(CROSS_LABEL))\n        };\n      } catch (e) {\n        cross = fit;\n      }\n\n      try {\n        validation = {\n          X: unwrapMatrix(this.model.X(VALIDATION_LABEL)),\n          y: unwrapMatrix(this.model.y(VALIDATION_LABEL))\n        };\n      } catch (e) {\n        validation = fit;\n      }\n\n      let unwrappedCandidates = candidates.map(term => {\n        let fit;\n        try {\n          fit = unwrapMatrix(term.col(FIT_LABEL));\n        } catch (e) {}\n\n        let lag = Math.max(this.model.highestLag(), term.lag);\n        let cross;\n        let validation;\n\n        try {\n          cross = unwrapMatrix(term.col(CROSS_LABEL));\n          validation = unwrapMatrix(term.col(VALIDATION_LABEL));\n        } catch (e) {\n          cross = fit;\n          validation = fit;\n        }\n\n        if (fit) {\n          transferables.push(fit.data, cross.data);\n          transferables.push(fit.data, validation.data);\n        }\n\n        return { fit, lag, cross, validation };\n      });\n\n      this.worker.postMessage({\n        fit,\n        cross,\n        validation,\n        candidates: unwrappedCandidates,\n        jobId: thisJobId\n      }, transferables);\n    });\n  }\n\n}\n\nmodule.exports = CandidateWorker;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/CandidateWorker.js\n// module id = 348\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/CandidateWorker.js?")},349:/*!*******************************!*\
  !*** ./engine/model/Model.js ***!
  \*******************************/
function(module,exports,__webpack_require__){eval("\nconst Matrix = __webpack_require__(/*! ../matrix */ 65);\nconst lstsq = __webpack_require__(/*! ../regression */ 144).lstsq;\nconst statistics = __webpack_require__(/*! ../statistics */ 112);\n\nconst utils = __webpack_require__(/*! ../utils */ 68);\nconst perf = __webpack_require__(/*! ../perf */ 175);\nconst Observable = __webpack_require__(/*! ../observable */ 354);\nconst {\n  FIT_LABEL,\n  CROSS_LABEL,\n  VALIDATION_LABEL,\n  LOG,\n  K_ORDER_DIFFERENCE,\n  STANDARDIZE,\n  RESCALE,\n  DELETE\n} = __webpack_require__(/*! ../labels.json */ 66);\n\nconst CandidateWorker = __webpack_require__(/*! ./CandidateWorker */ 348);\nconst TermPool = __webpack_require__(/*! ./TermPool */ 351);\nconst CacheMixin = __webpack_require__(/*! ./CacheMixin */ 229);\nconst combos = __webpack_require__(/*! ./combos */ 352);\n\nconst _data = Symbol('data');\nconst _exponents = Symbol('exponents');\nconst _multiplicands = Symbol('multiplicands');\nconst _lags = Symbol('lags');\nconst _dependent = Symbol('dependent');\nconst _use_cols = Symbol('useCols');\nconst _subsets = Symbol('subsets');\nconst _terms = Symbol('terms');\nconst _cand_workers = Symbol('candWorkers');\n\nconst INTERCEPT = [[0, 0, 0]];\n\nconst N_CANDIDATE_WORKERS = 8;\n\nclass Model extends CacheMixin(Observable) {\n\n  constructor() {\n    super();\n\n    this[_data] = {};\n    this[_data][FIT_LABEL] = new Matrix(0, 0);\n    this[_exponents] = [1];\n\n    this[_multiplicands] = [1];\n    this[_lags] = [0];\n    this[_dependent] = 0;\n    this[_use_cols] = [];\n\n    this[_subsets] = {};\n    this[_subsets][FIT_LABEL] = [];\n\n    try {\n      this[_cand_workers] = utils.range(0, N_CANDIDATE_WORKERS).map(() => new CandidateWorker(this));\n    } catch (e) {\n      // Set this to null so we know workers are unavailable and can fallback\n      // to single-threaded operation\n      this[_cand_workers] = null;\n    }\n\n    this.termpool = new TermPool(this);\n    this[_terms] = [this.termpool.get(INTERCEPT)];\n  }\n\n  clear() {\n    this[_terms] = [];\n    this.uncache('X');\n    this.uncache('y');\n    this.uncache('highestLag');\n    this.fire('clear');\n    return this;\n  }\n\n  transformColumn(label, data) {\n    var index = data.index;\n    if (index === undefined || isNaN(index)) {\n      return this;\n    }\n    var data_labels = data.data_labels || [FIT_LABEL, CROSS_LABEL, VALIDATION_LABEL];\n    // Need to do this for all dataset and not just \"fit\" data\n    // If clear cross and validation data in UI, doesn't clear respective data in Model, so will throw error\n    data_labels.map(data_label => {\n      if (this[_data][data_label]) {\n        var col = this[_data][data_label].col(index);\n        switch (label) {\n          case DELETE:\n            this.setData(this[_data][data_label].delColumn(index), data_label);\n            break;\n          case LOG:\n            var transform_col = statistics.compute(label, { X: col });\n            // this[_data][data_label] = this[_data][data_label].appendM(transform_col);\n            this.setData(this[_data][data_label].appendM(transform_col), data_label);\n            break;\n          case K_ORDER_DIFFERENCE:\n            var k = data.k;\n            var transform_col = statistics.compute(label, { X: col, k: k });\n            // this[_data][data_label] = this[_data][data_label].appendM(transform_col);\n            this.setData(this[_data][data_label].appendM(transform_col), data_label);\n            break;\n          case STANDARDIZE:\n            var mean = statistics.compute(\"mean\", { X: col });\n            var std = statistics.compute(\"std\", { X: col, mean: mean });\n            console.log(\"Mean\", mean);\n            console.log(\"Std\", std);\n            var transform_col = statistics.compute(label, { X: col, mean: mean, std: std });\n            // this[_data][data_label] = this[_data][data_label].appendM(transform_col);\n            this.setData(this[_data][data_label].appendM(transform_col), data_label);\n            break;\n          case RESCALE:\n            var rms = statistics.compute(\"RMS\", { X: col });\n            var transform_col = statistics.compute(label, { X: col, RMS: rms });\n            // this[_data][data_label] = this[_data][data_label].appendM(transform_col);\n            this.setData(this[_data][data_label].appendM(transform_col), data_label);\n            break;\n          default:\n            break;\n        }\n      }\n    });\n    this.fire('dataTransform', { label, index });\n    return this;\n  }\n\n  setData(data, label = FIT_LABEL) {\n    data = data == null ? undefined : data;\n    label = label == null ? FIT_LABEL : label;\n\n    if (data && !(data instanceof Matrix)) {\n      data = new Matrix(data);\n    }\n    if (data) {\n      if (label !== FIT_LABEL && data.shape[1] !== this[_data][FIT_LABEL].shape[1]) {\n        // throw new Error(\n        //   `Data for '${label}' is not the same shape as '${FIT_LABEL}'`\n        // );\n      } else {\n        this[_use_cols] = utils.range(0, data.shape[1]);\n      }\n    }\n    var curr_data = this[_data][label];\n    this[_data][label] = data;\n    this[_subsets][label] = data ? utils.range(0, data.shape[0]) : undefined;\n\n    this[_terms] = this[_terms].map(term => term.isIntercept ? this.termpool.get(INTERCEPT) : term);\n    this.uncache('X');\n    this.uncache('y');\n    this.uncache('data');\n    this.uncache('highestLag');\n\n    this.termpool.uncache();\n    this.fire('setData', { data, label });\n    // First time importing data\n    if (curr_data === undefined && (label == CROSS_LABEL || label == VALIDATION_LABEL) && data && data.shape[1] < this[_data][FIT_LABEL].shape[1]) {\n      this.fire('propogateTransform', { data_label: label });\n    }\n    return this;\n  }\n\n  getCandidateTerms() {\n    // Candidates from exp / mults / lag\n    let independent = this[_use_cols].filter(col => col !== this[_dependent]);\n\n    let candidates = combos.generateTerms(this[_dependent], independent, this[_exponents], this[_multiplicands], this[_lags]).map(this.termpool.get.bind(this.termpool));\n\n    // Intercept candidate (column of 1s)\n    candidates.unshift(this.termpool.get(INTERCEPT));\n\n    return candidates;\n  }\n\n  getCandidates() {\n    if (this[_cand_workers] == null) {\n      return this.getCandidatesSync();\n    }\n\n    this.fire('getCandidates.start');\n\n    perf.start('get-candidate-terms');\n    let candidates = this.getCandidateTerms();\n    perf.end('get-candidate-terms');\n\n    // For each candidate, get the stats for it alongside terms in the model\n    // If using workers, distribute the terms among them\n    candidates = candidates.filter(cand => !this[_terms].includes(cand));\n\n    let candsPerWorker = utils.split(candidates, this[_cand_workers].length);\n    let progress = utils.zeros(this[_cand_workers].length);\n\n    // Called by each worker after some number of candidates have been computed\n    let onProgress = (workerId, numFinished) => {\n      progress[workerId] = numFinished;\n      this.fire('getCandidates.each', {\n        curr: utils.sum(progress),\n        total: candidates.length\n      });\n    };\n\n    // Pass a chunk of candidates to each worker to be computed\n    let workerPromises = candsPerWorker.map((cands, i) => this[_cand_workers][i].compute(cands, onProgress));\n\n    return Promise.all(workerPromises).then(candidates => {\n      this.fire('getCandidates.end');\n      return utils.join(candidates);\n    });\n  }\n\n  getLabelData(label) {\n    return this[_data][label];\n  }\n\n  getModel(testLabel) {\n    let highestLag = this.highestLag(),\n        X = this.X().lo(highestLag),\n        y = this.y().lo(highestLag);\n\n    let stats = statistics(lstsq(X, y));\n\n    // If the model we want is not the default label (fit data), compute lstsq\n    // with whichever dataset is requested\n    if (testLabel != null) {\n      stats = statistics(lstsq(this.X(testLabel).lo(highestLag), this.y(testLabel).lo(highestLag), stats.weights));\n    }\n\n    let predicted = Array.from(stats.yHat.data);\n    let terms = this[_terms].map((term, i) => ({\n      term: term.valueOf(),\n      coeff: stats.weights.get(i, 0),\n      stats: {\n        t: stats.t.get(i, 0),\n        pt: stats.pt.get(i, 0)\n      }\n    }));\n\n    let residuals = stats.y.sub(stats.yHat);\n    residuals = residuals.data;\n\n    return {\n      highestLag: this.highestLag(),\n      terms,\n      stats,\n      predicted,\n      residuals\n    };\n  }\n\n  getCandidatesSync() {\n    this.fire('getCandidates.start');\n\n    let candidates = this.getCandidateTerms();\n    let results;\n\n    results = candidates.filter(cand => !this[_terms].includes(cand)).map((candidate, i) => {\n      this.fire('getCandidates.each', { curr: i, total: candidates.length });\n\n      try {\n        let stats = candidate.getStats();\n        return {\n          term: candidate.valueOf(),\n          coeff: stats.coeff,\n          stats\n        };\n      } catch (e) {\n        return null;\n      }\n    }).filter(cand => cand != null);\n\n    this.fire('getCandidates.end');\n    return Promise.resolve(results);\n  }\n\n  setExponents(exponents) {\n    this[_exponents] = exponents.slice();\n    this.fire('setExponents', exponents);\n    return this;\n  }\n\n  setMultiplicands(multiplicands) {\n    this[_multiplicands] = utils.range(1, multiplicands + 1);\n    this.fire('setMultiplicands', multiplicands);\n    return this;\n  }\n\n  setDependent(dependent) {\n    this[_dependent] = dependent;\n    this[_terms] = [this.termpool.get(INTERCEPT)];\n    this.uncache();\n    this.fire('setDependent', dependent);\n    return this;\n  }\n\n  setColumns(cols) {\n    this[_use_cols] = cols.slice();\n\n    this[_terms] = [this.termpool.get(INTERCEPT)];\n    this.uncache();\n    this.fire('setColumns', cols);\n    return this;\n  }\n\n  setLags(lags) {\n    if (!lags.every(lag => lag >= 0)) {\n      this.fire('error', 'Cannot have negative lag');\n      return this;\n    }\n    this[_lags] = lags.slice();\n    this.fire('setLags', lags);\n    return this;\n  }\n\n  subset(label = FIT_LABEL, start, end) {\n    this.uncache('X');\n    this.uncache('y');\n    this.uncache('data');\n\n    if (this[_data][label] == null) {\n      throw new ReferenceError('Cannot find data for \\'' + label + '\\'');\n    }\n\n    if (!Array.isArray(start)) {\n      start = utils.range(start, end || this[_data][label].shape[0]);\n    } else {\n      start = start.slice();\n    }\n    this[_subsets][label] = start;\n\n    this.fire('subset', start);\n    return this;\n  }\n\n  addTerm(term) {\n    let found = this[_terms].find(t => t.equals(term));\n\n    if (!found) {\n      found = this.termpool.get(term);\n      this[_terms].push(found);\n      this.uncache('X');\n      this.uncache('y');\n    }\n\n    this.uncache('highestLag');\n    this.fire('addTerm', term);\n    return this;\n  }\n\n  removeTerm(term) {\n    this[_terms] = this[_terms].filter(t => !t.equals(term));\n    this.uncache('X');\n    this.uncache('y');\n    this.uncache('highestLag');\n    this.fire('removeTerm', term);\n    return this;\n  }\n\n  highestLag() {\n    return this[_terms].reduce((high, term) => Math.max(high, term.lag), 0);\n  }\n\n  X(label = FIT_LABEL) {\n    if (this[_data][label] == null) {\n      throw new ReferenceError('Cannot find data for \\'' + label + '\\'');\n    }\n    return this[_terms].reduce((prev, curr) => prev.hstack(curr.col(label)), new Matrix(this[_subsets][label].length, 0));\n  }\n\n  y(label = FIT_LABEL) {\n    return this.data(label).subset(':', this[_dependent]);\n  }\n\n  data(label = FIT_LABEL) {\n    if (this[_data][label] == null) {\n      throw new ReferenceError('Cannot find data for \\'' + label + '\\'');\n    }\n    return this[_data][label].subset(this[_subsets][label]);\n  }\n\n  computeSensitivity(index, label = FIT_LABEL) {\n    if (index == undefined) {\n      return this;\n    }\n    let model = this; // to use within loops below\n    let num_rows = model[_data][FIT_LABEL].shape[0];\n    let derivative = new Matrix(num_rows, 1, new Array(num_rows).fill(0));\n\n    this.terms.forEach(function (t) {\n      let contains_variable = false; // Check if the variable we are deriving on is in this term\n      let derivative_part = new Matrix(num_rows, 1, new Array(num_rows).fill(1));\n\n      // One coefficient per term\n      let term_coef = 2 * t.getStats()['coeff'];\n\n      // t.valueOf() is an Array which contains information for each variable of the term\n      let tValues = t.valueOf();\n      tValues.forEach(function (tValue) {\n        let current_index = tValue[0];\n        let current_exp = tValue[1];\n\n        // Get the current column of data\n        let current_col = model[_data][label].col(current_index)['data'];\n\n        let part;\n        if (current_index == index) {\n          // Current variable exists in term, should be used in derivative\n          contains_variable = true;\n\n          // current_exp * [COLUMN DATA]^(current_exp - 1)\n          part = statistics.compute('sensitivity_part', { data: current_col, exp: current_exp, derivative: true });\n        } else {\n          // [COLUMN DATA]^(current_exp)\n          part = statistics.compute('sensitivity_part', { data: current_col, exp: current_exp, derivative: false });\n        }\n        derivative_part = derivative_part.dotMultiply(new Matrix(num_rows, 1, part));\n      });\n\n      if (contains_variable) {\n        // Add to overall derivative\n        derivative = derivative.add(derivative_part.dotMultiply(term_coef));\n      }\n    });\n\n    return { index: index, sensitivity: derivative.data };\n  }\n\n  getSensitivity(index, label = FIT_LABEL) {\n    let res = this.computeSensitivity(index, label);\n    this.fire('getSensitivity', res);\n    return this;\n  }\n\n  deleteSensitivity(index) {\n    this.fire('deleteSensitivity', { index: index });\n    return this;\n  }\n\n  updateSensitivity(index, label = FIT_LABEL) {\n    let res = this.computeSensitivity(index, label);\n    this.fire('updateSensitivity', res);\n    return this;\n  }\n\n  computeImportanceRatio(index, label = FIT_LABEL) {\n    if (index == undefined) {\n      return this;\n    }\n    let model = this;\n    let num_rows = model[_data][FIT_LABEL].shape[0];\n    let current_col = model[_data][label].col(index);\n    let dependent_col = model[_data][label].col(model[_dependent]);\n\n    let sensitivity = this.computeSensitivity(index, label)['sensitivity'];\n    // Convert to matrix\n    sensitivity = new Matrix(num_rows, 1, sensitivity);\n\n    // Compute Standard Deviation of independent variable\n    let mean_x = statistics.compute('mean', { X: current_col });\n    let std_x = statistics.compute('std', { X: current_col, mean: mean_x });\n\n    // Compute Standard Deviation of dependent variable\n    let mean_y = statistics.compute('mean', { X: dependent_col });\n    let std_y = statistics.compute('std', { X: dependent_col, mean: mean_y });\n\n    let importance_ratio = sensitivity.dotMultiply(std_x / std_y);\n\n    return { index: index, importanceRatio: importance_ratio.data };\n  }\n\n  getImportanceRatio(index, label = FIT_LABEL) {\n    let res = this.computeImportanceRatio(index, label);\n    this.fire('getImportanceRatio', res);\n    return this;\n  }\n\n  deleteImportanceRatio(index) {\n    this.fire('deleteImportanceRatio', { index: index });\n    return this;\n  }\n\n  updateImportanceRatio(index, label = FIT_LABEL) {\n    let res = this.computeImportanceRatio(index, label);\n    this.fire('updateImportanceRatio', res);\n    return this;\n  }\n\n  get labels() {\n    return Object.keys(this[_subsets]).filter(data_label => this[_subsets][data_label]);\n  }\n\n  get terms() {\n    return this[_terms].slice();\n  }\n\n}\n\nCacheMixin.cache(Model, 'highestLag');\nCacheMixin.cache(Model, 'X', [FIT_LABEL]);\nCacheMixin.cache(Model, 'y', [FIT_LABEL]);\nCacheMixin.cache(Model, 'data', [FIT_LABEL]);\n\nmodule.exports = Model;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/Model.js\n// module id = 349\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/Model.js?")},350:/*!******************************!*\
  !*** ./engine/model/Term.js ***!
  \******************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nconst CacheMixin = __webpack_require__(/*! ./CacheMixin */ 229);\nconst statistics = __webpack_require__(/*! ../statistics */ 112);\nconst lstsq = __webpack_require__(/*! ../regression */ 144).lstsq;\nconst Matrix = __webpack_require__(/*! ../matrix */ 65);\nconst {\n  FIT_LABEL,\n  CROSS_LABEL\n} = __webpack_require__(/*! ../labels.json */ 66);\n\n/**\n * Private members\n *\n * @private\n */\nconst _parts = Symbol('parts');\nconst _model = Symbol('model');\n\n/**\n * Term is a combination of input columns, exponents, and lags, such as x^2*y^3.\n *\n * @class Term\n */\nclass Term extends CacheMixin() {\n\n  /**\n   * Creates a new Term.\n   *\n   * @constructor\n   * @param {Model}             model         Model that owns this Term\n   * @param {[num, num, num][]} parts         List of triples of numbers\n   * @param {number}            parts[i][0]   First is the index of a column\n   * @param {number}            parts[i][1]   Second is the exponent to raise\n   *                                          that column to\n   * @param {number}           [parts[i][2]]  Third is the lag to apply to that\n   *                                          column\n   */\n  constructor(model, parts) {\n    super();\n    if (!parts.every(Array.isArray)) {\n      throw new TypeError('Part does not match: [col, exp (,lag)]');\n    }\n\n    this[_parts] = parts.map(part => {\n      if (part.length < 2) {\n        throw new TypeError('Part does not match: [col, exp (,lag)]');\n      }\n      if (part.length < 3) {\n        return part.concat(0);\n      }\n      return part.slice();\n    });\n\n    this[_model] = model;\n    this.isIntercept = parts[0][0] === 0 && parts[0][1] === 0 && parts.length === 1;\n\n    try {\n      this.col();\n    } catch (e) {\n      // TODO: Pass up errors so that suspicious columns can be marked\n    }\n  }\n\n  /**\n   * Computes least squares regression and analysis statistics on the parent\n   * model PLUS this term.\n   *\n   * @return {t: number, mse: number} Statistics for the regression\n   */\n  getStats() {\n    try {\n      // If we have cross data, use that to compute stats on lstsq\n      // Otherwise, just use the fit data\n      let regression = lstsq(this.X(FIT_LABEL), this.y(FIT_LABEL));\n      let stats = statistics(regression);\n      let t = stats.t.get(0, stats.t.shape[0] - 1);\n      let pt = stats.pt.get(0, stats.pt.shape[0] - 1);\n\n      Object.assign(regression, {\n        X: this.X(CROSS_LABEL),\n        y: this.y(CROSS_LABEL)\n      });\n\n      stats = statistics(regression);\n\n      stats.coeff = stats.weights.get(0, stats.weights.shape[0] - 1);\n      stats.t = t;\n      stats.pt = pt;\n      delete stats.weights;\n\n      return stats;\n    } catch (e) {\n      console.error(e);\n      return NaN;\n    }\n  }\n\n  X(subset = FIT_LABEL) {\n    let lag = Math.max(this[_model].highestLag(), this.lag);\n\n    try {\n      return this[_model].X(subset).hstack(this.col(subset)).lo(lag);\n    } catch (e) {\n      if (subset !== FIT_LABEL) {\n        return this.X(FIT_LABEL);\n      }\n      throw e;\n    }\n  }\n\n  y(subset = FIT_LABEL) {\n    let lag = Math.max(this[_model].highestLag(), this.lag);\n    try {\n      return this[_model].y(subset).lo(lag);\n    } catch (e) {\n      if (subset !== FIT_LABEL) {\n        return this.y(FIT_LABEL);\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Determines if this term is equivalent to `other`.\n   *\n   * @param {Term | [num, num, num][]}  other Term to compare against\n   * @return {boolean} True if the terms are equivalent, false otherwise\n   */\n  equals(other) {\n    other = other.valueOf().map(part => {\n      part = part.concat(0);\n      part.length = 3;\n      return part;\n    });\n    return Term.hash(other) === Term.hash(this);\n  }\n\n  /**\n   * Returns the information necessary to reconstruct the term in a plain\n   * object (except the reference to the model).\n   *\n   * @return {[num, num, num][]} List of [col, exp, lag] triples\n   */\n  valueOf() {\n    return this[_parts].slice();\n  }\n\n  /**\n   * Compute the data column for a given matrix.\n   *\n   * @return {Matrix<n,1>} n x 1 Matrix -- polynomial combo of columns in term\n   */\n  col(subset = FIT_LABEL) {\n    try {\n      let data = this[_model].data(subset),\n          prod = Matrix.zeros(data.shape[0], 1).add(1),\n          i,\n          col;\n\n      for (i = 0; i < this[_parts].length; i += 1) {\n        col = data.col(this[_parts][i][0]);\n\n        // Check for negative exponent & potential 0 value\n        if (col.max() * col.min() <= 0 && this[_parts][i][1] < 0) {\n          throw new Error(`Divide by zero error for column ${this[_parts][i][0]}`);\n        }\n\n        prod = prod.dotMultiply(col.dotPow(this[_parts][i][1]).shift(this[_parts][i][2]));\n      }\n\n      return prod;\n    } catch (e) {\n      if (subset !== FIT_LABEL) {\n        return this.col(FIT_LABEL);\n      }\n      throw e;\n    }\n  }\n\n  get lag() {\n    return Math.max.apply(null, this[_parts].map(part => part[2]));\n  }\n\n  /**\n   * Give a representation of the term in a pretty format.\n   *\n   * @return {string} Representation of this term\n   */\n  inspect(depth, options) {\n    return 'Term < ' + this[_parts].map(t => String.fromCharCode(t[0] + 97) + '^' + t[1] + '[' + t[2] + ']').join(' * ') + ' >';\n  }\n\n  static hash(term) {\n    return term.valueOf().map(part => `(${part.concat(0).slice(0, 3).toString()})`).toString();\n  }\n\n}\n\nCacheMixin.cache(Term, 'col', [FIT_LABEL]);\n\nmodule.exports = Term;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/Term.js\n// module id = 350\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/Term.js?")},351:/*!**********************************!*\
  !*** ./engine/model/TermPool.js ***!
  \**********************************/
function(module,exports,__webpack_require__){eval("\nconst Term = __webpack_require__(/*! ./Term */ 350);\n\nclass TermPool {\n\n  constructor(model) {\n    this.model = model;\n    this.terms = {};\n  }\n\n  get(term) {\n    let found = this.terms[Term.hash(term)];\n\n    if (!found) {\n      found = new Term(this.model, term);\n      this.terms[Term.hash(found.valueOf())] = found;\n    }\n\n    return found;\n  }\n\n  uncache() {\n    Object.values(this.terms).forEach(term => term.uncache('col'));\n  }\n\n}\n\nmodule.exports = TermPool;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/TermPool.js\n// module id = 351\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/TermPool.js?")},352:/*!********************************!*\
  !*** ./engine/model/combos.js ***!
  \********************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nconst utils = __webpack_require__(/*! ../utils */ 68);\n\n/**\n * Generate all combinations of k terms.\n *\n * @param {*[]}     terms         Array of items to combine\n * @param {number}  k             # of items in every combination\n * @param {boolean} [replacement] If true, an item from `terms` can be repeated\n *                                in a single combination\n */\nlet combinations = function (terms, k, replacement) {\n  var combos = [];\n  var i;\n\n  if (k < 1) {\n    return combos;\n  }\n  if (k === 1) {\n    return terms.map(term => [term]);\n  }\n\n  for (i = 0; i < terms.length; i += 1) {\n    var subCombos = combinations(\n    // with replacements    => slice at i (include the current term)\n    // without replacements => slice at i + 1 (exclude current term)\n    terms.slice(i + !replacement), k - 1, replacement);\n    // prepend the current term to each sub combo\n    combos = combos.concat(subCombos.map(combo => [terms[i]].concat(combo)));\n  }\n  return combos;\n};\n\n/**\n * Generates all combinations of k items using one item from each bin in `bins`.\n *\n *    bins = [[0, 1], [2, 3]], k = 2\n *  ->[[0, 2], [0, 3], [1, 2], [1, 3]]\n *\n *\n * @param {*[][]} bins  An array of arrays containing items. For each\n *                      combination, only one item from each bin can be present\n * @return {*[][]} Combos\n */\nlet combinationsFromBins = function (bins, k) {\n  var combos = [];\n  var i;\n\n  if (k < 1) {\n    return combos;\n  }\n  if (bins.length <= 0) {\n    return combos;\n  }\n  if (k === 1) {\n    return utils.join(bins).map(term => [term]);\n  }\n  for (i = 0; i < bins[0].length; i += 1) {\n    var subCombos = combinationsFromBins(bins.slice(1), k - 1);\n    combos = combos.concat(subCombos.map(combo => [bins[0][i]].concat(combo)));\n  }\n  return combos.concat(combinationsFromBins(bins.slice(1), k));\n};\n\n/**\n * Generates all possible combinations of exponentiated terms given a list of\n * exponents, a list of # of multiplicands, and a list of lags\n *\n * @param {number[]}  dep         Dependent column index from the dataset\n * @param {number[]}  indep       Independent column indices from the dataset\n * @param {number[]}  exponents   Array of exponents ([1, 2] means x, x^2)\n * @param {number[]}  multipliers Array of # of multiplicands ([1] means only\n *                                one multiplicand per term)\n * @param {number[]}  lags        Array of lags (similar to exponents)\n * @return {[number, number][][]} List of terms\n */\nlet generateTerms = function (dep, indep, exponents, multipliers, lags) {\n  let bins = indep.map(i => utils.join(exponents.map(e => lags.map(l => [i, e, l]))));\n\n  // Include dependent column, but only with lag > 0\n  lags = lags.filter(l => l > 0);\n  bins.unshift(utils.join(exponents.map(e => lags.map(l => [dep, e, l]))));\n\n  let combosForMults = utils.join(multipliers.map(m => combinationsFromBins(bins, m)));\n\n  return combosForMults;\n};\n\nmodule.exports.generateTerms = generateTerms;\nmodule.exports.combinations = combinations;\nmodule.exports.combinationsFromBins = combinationsFromBins;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/combos.js\n// module id = 352\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/combos.js?")},353:/*!*****************************************!*\
  !*** ./engine/observable/Observable.js ***!
  \*****************************************/
function(module,exports){eval("\nconst _events = Symbol('events');\nconst _listeners = Symbol('listeners');\nconst _listenerCount = Symbol('listenerCount');\n\nclass Observable {\n\n  constructor() {\n    this[_events] = {};\n    this[_listeners] = {};\n    this[_listenerCount] = 0;\n  }\n\n  on(event, handler) {\n    // If an array of events, register for each event\n    if (Array.isArray(event)) {\n      return event.map(ev => this.on(ev, handler));\n    }\n\n    // Otherwise, register the sole event\n    let id = this[_listenerCount] += 1;\n\n    this[_listeners][id] = handler;\n\n    if (!this[_events][event]) {\n      this[_events][event] = [];\n    }\n\n    this[_events][event].push(id);\n    return id;\n  }\n\n  removeListener(id) {\n    // If an array of ids, unregister for each id\n    if (Array.isArray(id)) {\n      return id.every(ev => this.removeListener(ev, id));\n    }\n\n    delete this[_listeners][id];\n\n    Object.keys(this[_events]).forEach(event => this[_events][event] = this[_events][event].filter(handlerId => handlerId !== id));\n    return true;\n  }\n\n  fire(event, data) {\n    if (!this[_events][event]) {\n      this[_events][event] = [];\n    }\n    this[_events][event].forEach(id => this[_listeners][id](data));\n  }\n\n}\n\nmodule.exports = Observable;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/observable/Observable.js\n// module id = 353\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/observable/Observable.js?")},354:/*!************************************!*\
  !*** ./engine/observable/index.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("\nmodule.exports = __webpack_require__(/*! ./Observable */ 353);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/observable/index.js\n// module id = 354\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/observable/index.js?")},356:/*!****************************************!*\
  !*** ./engine/worker/engine-worker.js ***!
  \****************************************/
function(module,exports,__webpack_require__){"use strict";eval("/*global onmessage, postMessage*/\n\n\n__webpack_require__(/*! ./subworkers */ 67);\n\nconst perf = __webpack_require__(/*! ../perf */ 175);\nconst statsMeta = __webpack_require__(/*! ../statistics/metadata.json */ 145);\nconst Model = __webpack_require__(/*! ../model */ 342);\nconst {\n  FIT_LABEL, CROSS_LABEL, VALIDATION_LABEL,\n  LOG,\n  K_ORDER_DIFFERENCE,\n  STANDARDIZE,\n  RESCALE,\n  DELETE\n} = __webpack_require__(/*! ../labels.json */ 66);\n\nconst Transformation = __webpack_require__(/*! ../../interface/components/transform/label.json */ 113);\n\nconst getCandidateProgressInterval = 50;\nlet onGetCandidateId = 0;\nlet m = initializeModel();\n\nfunction log() {\n  console.debug('[Engine]:', ...arguments);\n};\n\nfunction initializeModel() {\n  let m = new Model();\n\n  m.on('getCandidates.start', () => postMessage({\n    type: 'progress.start',\n    data: {}\n  }));\n\n  m.on('getCandidates.start', () => perf.start('get-candidates'));\n  m.on('getCandidates.end', () => {\n    perf.end('get-candidates');\n    perf.report('get-candidates', 3);\n  });\n\n  // Subscribe to progress changes\n  onGetCandidateId = m.on('getCandidates.each', data => {\n    if (data.curr % getCandidateProgressInterval === 0) {\n      postMessage({\n        type: 'progress',\n        data: { curr: data.curr, total: data.total }\n      });\n    }\n  });\n\n  m.on('getCandidates.end', () => postMessage({\n    type: 'progress.end',\n    data: {}\n  }));\n\n  m.on(\"dataTransform\", () => {\n    postMessage({\n      type: `data:transform`,\n      data: {\n        // This sets the data in the Model, but Model.coffee will not update, need to fire back to adapter new data\n        fit: m.getLabelData(FIT_LABEL) ? m.getLabelData(FIT_LABEL).toJSON() : undefined,\n        cross: m.getLabelData(CROSS_LABEL) ? m.getLabelData(CROSS_LABEL).toJSON() : undefined,\n        validation: m.getLabelData(VALIDATION_LABEL) ? m.getLabelData(VALIDATION_LABEL).toJSON() : undefined\n      }\n    });\n  });\n\n  m.on('propogateTransform', data => {\n    postMessage({\n      type: `propogateTransform`,\n      data: {\n        data_label: data.data_label\n      }\n    });\n  });\n\n  m.on('error', error => postMessage({ type: 'error', data: error }));\n\n  m.on('getSensitivity', data => {\n    postMessage({\n      type: 'model:getSensitivity',\n      data: data\n    });\n  });\n\n  m.on('deleteSensitivity', data => {\n    postMessage({\n      type: 'model:deleteSensitivity',\n      data: data\n    });\n  });\n\n  m.on('updateSensitivity', data => {\n    postMessage({\n      type: 'model:updateSensitivity',\n      data: data\n    });\n  });\n\n  m.on('getImportanceRatio', data => {\n    postMessage({\n      type: 'model:getImportanceRatio',\n      data: data\n    });\n  });\n\n  m.on('deleteImportanceRatio', data => {\n    postMessage({\n      type: 'model:deleteImportanceRatio',\n      data: data\n    });\n  });\n\n  m.on('updateImportanceRatio', data => {\n    postMessage({\n      type: 'model:updateImportanceRatio',\n      data: data\n    });\n  });\n\n  return m;\n}\n\n// Whenever a parameter changes, let's update the UI\nlet subscriptionIds = [];\nlet subscribeToChanges = (m, updateNow = true) => {\n  m.removeListener(subscriptionIds);\n\n  subscriptionIds = m.on(['setData', 'setExponents', 'setMultiplicands', 'setDependent', 'setLags', 'addTerm', 'removeTerm', 'clear', 'subset', 'setColumns', 'getSensitivity', 'deleteSensitivity', 'updateSensitivity', 'getImportanceRatio', 'deleteImportanceRatio', 'updateImportanceRatio'], () => {\n    m.getCandidates().then(cands => postMessage({ type: 'candidates', data: cands }));\n    m.labels.forEach(label => postMessage({ type: `model:${label}`, data: m.getModel(label) }));\n  });\n\n  if (updateNow) {\n    m.fire('setData');\n  }\n};\nlet unsubscribeToChanges = m => m.removeListener(subscriptionIds);\n\n// By default, subscribe\n//subscribeToChanges(m, false);\n\n/**\n * Function calls off subscription handler from engine/model.js\n */\nonmessage = function (e) {\n  // If it's for a sub-worker, just ignore it\n  if (e.data._from != null) {\n    return;\n  }\n\n  let type = e.data.type,\n      data = e.data.data,\n      temp;\n\n  log(e.data);\n\n  switch (type) {\n    // only works because the event type is the same as the method name\n    case 'setExponents':\n    case 'setMultiplicands':\n    case 'setDependent':\n    case 'setColumns':\n    case 'setLags':\n    case 'addTerm':\n    case 'removeTerm':\n    case 'clear':\n      m[type](data);\n      break;\n\n    // this one's special\n    case 'setData':\n      m[type](data.data, data.label);\n      break;\n\n    case 'getTerms':\n      postMessage({ type: 'candidates', data: m.getCandidates() });\n      break;\n\n    case 'getStatisticsMetadata':\n      postMessage({ type: 'statisticsMetadata', data: statsMeta });\n      break;\n\n    case 'subscribeToChanges':\n      subscribeToChanges(m);\n      break;\n\n    case 'unsubscribeToChanges':\n      unsubscribeToChanges(m);\n      break;\n\n    case 'subset':\n      m.subset(data.label, data.start, data.end);\n      break;\n\n    case 'transformData':\n      switch (data.label) {\n        case Transformation.Transform.delete:\n          m.transformColumn(DELETE, {\n            index: data.index,\n            data_labels: data.data_labels\n          });\n          break;\n        case Transformation.Transform.log:\n          m.transformColumn(LOG, {\n            index: data.index,\n            data_labels: data.data_labels\n          });\n          break;\n        case Transformation.Transform.k_order_diff:\n          m.transformColumn(K_ORDER_DIFFERENCE, {\n            index: data.index,\n            k: data.k,\n            data_labels: data.data_labels\n          });\n          break;\n        case Transformation.Transform.standardize:\n          m.transformColumn(STANDARDIZE, {\n            index: data.index,\n            data_labels: data.data_labels\n          });\n          break;\n        case Transformation.Transform.rescale:\n          m.transformColumn(RESCALE, {\n            index: data.index,\n            data_labels: data.data_labels\n          });\n          break;\n        default:\n          break;\n      }\n      break;\n\n    case 'getSensitivity':\n      m.getSensitivity(data);\n      break;\n\n    case 'deleteSensitivity':\n      m.deleteSensitivity(data);\n      break;\n\n    case 'updateSensitivity':\n      m.updateSensitivity(data);\n      break;\n\n    case 'getImportanceRatio':\n      m.getImportanceRatio(data);\n      break;\n\n    case 'deleteImportanceRatio':\n      m.deleteImportanceRatio(data);\n      break;\n\n    case 'updateImportanceRatio':\n      m.updateImportanceRatio(data);\n      break;\n\n    case 'reset':\n      m = new Model();\n      break;\n\n    default:\n      postMessage({ type: 'error', data: 'Invalid type: ' + type });\n      break;\n\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/engine-worker.js\n// module id = 356\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/worker/engine-worker.js?")},65:/*!********************************!*\
  !*** ./engine/matrix/index.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("\nmodule.exports = __webpack_require__(/*! ./Matrix */ 176);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/index.js\n// module id = 65\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/matrix/index.js?")},66:/*!****************************!*\
  !*** ./engine/labels.json ***!
  \****************************/
function(module,exports){eval('module.exports = {\n\t"FIT_LABEL": "fit",\n\t"CROSS_LABEL": "cross",\n\t"VALIDATION_LABEL": "validation",\n\t"LOG": "log",\n\t"K_ORDER_DIFFERENCE": "k_order_difference",\n\t"STANDARDIZE": "standardize",\n\t"RESCALE": "rescale",\n\t"DELETE": "delete"\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/labels.json\n// module id = 66\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./engine/labels.json?')},67:/*!*************************************!*\
  !*** ./engine/worker/subworkers.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("(function () {\n\n  /* Detect if we're in a worker or not */\n  var isWorker = false;\n  try {\n    document;\n  } catch (e) {\n    isWorker = true;\n  }\n\n  if (isWorker) {\n    // Replace self.postMessage because webpack-dev-server doesn't recognize\n    // workers\n    let oldPostMessage = self.postMessage;\n    self.postMessage = (msg, otherthing) => {\n      try {\n        oldPostMessage(msg, otherthing);\n      } catch (e) {\n        console.warn(e.message);\n      }\n    };\n\n    // For some reason, nested workers on firefox sucks. So, just polyfill all\n    // of the browsers to make this work\n    if (true /* we don't really need to check this */) {\n        self.Worker = function (path) {\n          var that = this;\n          this.id = Math.random().toString(36).substr(2, 5);\n\n          this.eventListeners = {\n            \"message\": []\n          };\n          self.addEventListener(\"message\", function (e) {\n            if (e.data._from === that.id) {\n              var newEvent = new MessageEvent(\"message\");\n              newEvent.initMessageEvent(\"message\", false, false, e.data.message, that, \"\", null, []);\n              that.dispatchEvent(newEvent);\n              if (that.onmessage) {\n                that.onmessage(newEvent);\n              }\n            }\n          });\n\n          var location = self.location.pathname;\n          var absPath = path; //location.substring(0, location.lastIndexOf('/')) + '/' + path;\n          self.postMessage({\n            _subworker: true,\n            cmd: 'newWorker',\n            id: this.id,\n            path: absPath\n          });\n        };\n        Worker.prototype = {\n          onerror: null,\n          onmessage: null,\n          postMessage: function (message) {\n            self.postMessage({\n              _subworker: true,\n              id: this.id,\n              cmd: 'passMessage',\n              message: message\n            });\n          },\n          terminate: function () {\n            self.postMessage({\n              _subworker: true,\n              cmd: 'terminate',\n              id: this.id\n            });\n          },\n          addEventListener: function (type, listener, useCapture) {\n            if (this.eventListeners[type]) {\n              this.eventListeners[type].push(listener);\n            }\n          },\n          removeEventListener: function (type, listener, useCapture) {\n            if (!(type in this.eventListeners)) return;\n            var index = this.eventListeners[type].indexOf(listener);\n            if (index !== -1) {\n              this.eventListeners[type].splice(index, 1);\n            }\n          },\n          dispatchEvent: function (event) {\n            var listeners = this.eventListeners[event.type];\n            for (var i = 0; i < listeners.length; i++) {\n              listeners[i](event);\n            }\n          }\n        };\n      }\n  }\n\n  var allWorkers = {};\n  var cmds = {\n    newWorker: function (event) {\n      var worker = new Worker(event.data.path);\n      worker.addEventListener(\"message\", function (e) {\n        var envelope = {\n          _from: event.data.id,\n          message: e.data\n        };\n        event.target.postMessage(envelope);\n      });\n      allWorkers[event.data.id] = worker;\n    },\n    terminate: function (event) {\n      allWorkers[event.data.id].terminate();\n    },\n    passMessage: function (event) {\n      allWorkers[event.data.id].postMessage(event.data.message);\n    }\n  };\n  var messageRecieved = function (event) {\n    if (event.data._subworker) {\n      cmds[event.data.cmd](event);\n    }\n  };\n\n  /* Hijack Worker */\n  var oldWorker = window.Worker;\n  window.Worker = function (path) {\n\n    var blobIndex = path.indexOf('blob:');\n\n    if (blobIndex !== -1 && blobIndex !== 0) {\n      path = path.substring(blobIndex);\n    }\n\n    var newWorker = new oldWorker(path);\n    newWorker.addEventListener(\"message\", messageRecieved);\n\n    return newWorker;\n  };\n})();\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/subworkers.js\n// module id = 67\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./engine/worker/subworkers.js?")},68:/*!*************************!*\
  !*** ./engine/utils.js ***!
  \*************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction nchars(n, char) {\n  n = Math.max(0, n);\n  return Array(n + 1).join(char);\n}\n\nlet nspaces = n => nchars(n, ' ');\n\nfunction pad(width, val) {\n  val = val || '';\n  return nspaces(width - ('' + val).length) + val;\n}\n\nlet range = module.exports.range = (start, end) => {\n  if (start >= end) {\n    return [];\n  }\n  return Array(end - start).join(' ').split(' ').map((_, i) => i + start);\n};\n\nlet zeros = module.exports.zeros = n => Array(n).join(' ').split(' ').map(() => 0);\n\nlet sum = module.exports.sum = arr => arr.reduce((tot, curr) => tot + curr);\n\nmodule.exports.convertRange = (str, length) => {\n  var range, start, end;\n\n  if (typeof str === 'number') {\n    return str < 0 ? [length + str] : [str];\n  }\n  if (typeof str !== 'string') {\n    return str.map(ind => ind < 0 ? length + ind : ind);\n  }\n\n  if ((range = str.split(':')).length > 1) {\n    start = parseInt(range[0]) || 0;\n    end = parseInt(range[1]) || length;\n\n    if (start < 0) {\n      start = length + start;\n    }\n    if (end < 0) {\n      end = length + end;\n    }\n    return module.exports.range(start, end);\n  }\n\n  throw new TypeError('Invalid range');\n};\n\nmodule.exports.formatNum = (leftwidth, rightwidth, val, nilDecimalChar = ' ') => {\n  val = '' + val;\n  var match = val.match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/),\n      whole = match[1],\n      frac = match[2],\n      repr = '';\n\n  if (frac.length > rightwidth) {\n    frac = frac.slice(0, rightwidth);\n  }\n  repr += nspaces(leftwidth - whole.length) + whole;\n  if (frac !== '' || rightwidth > 0) {\n    repr += '.';\n    repr += frac.slice(0, rightwidth) + nchars(rightwidth - frac.length, nilDecimalChar);\n  } else {\n    repr += nspaces(rightwidth + 1);\n  }\n  return repr;\n};\n\nlet padAll = module.exports.padAll = (lwidth, str) => {\n  if (Array.isArray(str)) {\n    return str.map(s => padAll(lwidth + s.length, s));\n  } else if (typeof str === 'string') {\n    return str.split('\\n').map(s => pad(lwidth + s.length, s)).join('\\n');\n  }\n  return pad(lwidth, str);\n};\n\nlet clone = module.exports.clone = obj => {\n  if (typeof obj !== 'object') {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n\n  let newObj = {};\n  Object.keys(obj).forEach(key => newObj[key] = clone(obj[key]));\n  return newObj;\n};\n\nlet split = module.exports.split = (arr, n) => {\n  let results = range(0, n).map(() => []);\n  let i;\n\n  for (i = 0; i < arr.length; i += 1) {\n    results[i % n].push(arr[i]);\n  }\n  return results;\n};\n\nlet splitToSize = module.exports.splitToSize = (arr, n) => {\n  let results = [];\n  let subset;\n  let i;\n\n  for (i = 0, subset = []; i < arr.length; i += 1) {\n    subset.push(arr[i]);\n    if ((i + 1) % n === 0) {\n      results.push(subset);\n      subset = [];\n    }\n  }\n  if (i % n !== 0) {\n    results.push(subset);\n  }\n  return results;\n};\n\nmodule.exports.join = arr => [].concat.apply([], arr);\n\nmodule.exports.sign = x => x < 0 ? -1 : x > 0 ? 1 : 0;\n\nmodule.exports.argmax = arr => arr.indexOf(Math.max.apply(null, arr));\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/utils.js\n// module id = 68\n// module chunks = 0 1 2\n\n//# sourceURL=webpack:///./engine/utils.js?")}});